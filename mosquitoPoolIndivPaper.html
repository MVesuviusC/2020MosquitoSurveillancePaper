<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title>mosquitoPoolIndivPaper</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <!-- jQuery -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jqueryui/1.10.3/jquery-ui.min.js"></script>
  
  <!-- bootstrap -->
  <!--<link href="https://netdna.bootstrapcdn.com/bootstrap/3.0.0/css/bootstrap.min.css" rel="stylesheet"  id="style">-->
  <script src="https://netdna.bootstrapcdn.com/bootstrap/3.0.0/js/bootstrap.min.js"></script>
  
  <!-- highlight.js -->
  <!--<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/7.3/styles/default.min.css" rel="stylesheet" id="code-style">-->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/7.3/highlight.min.js"></script>
  <script>
  hljs.LANGUAGES.r=function(a){var b="([a-zA-Z]|\\.[a-zA-Z.])[a-zA-Z0-9._]*";return{c:[a.HCM,{b:b,l:b,k:{keyword:"function if in break next repeat else for return switch while try tryCatch|10 stop warning require library attach detach source setMethod setGeneric setGroupGeneric setClass ...|10",literal:"NULL NA TRUE FALSE T F Inf NaN NA_integer_|10 NA_real_|10 NA_character_|10 NA_complex_|10"},r:0},{cN:"number",b:"0[xX][0-9a-fA-F]+[Li]?\\b",r:0},{cN:"number",b:"\\d+(?:[eE][+\\-]?\\d*)?L\\b",r:0},{cN:"number",b:"\\d+\\.(?!\\d)(?:i\\b)?",r:0},{cN:"number",b:"\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d*)?i?\\b",r:0},{cN:"number",b:"\\.\\d+(?:[eE][+\\-]?\\d*)?i?\\b",r:0},{b:"`",e:"`",r:0},{cN:"string",b:'"',e:'"',c:[a.BE],r:0},{cN:"string",b:"'",e:"'",c:[a.BE],r:0}]}}(hljs); </script>
  <!--<script type="text/javascript", src="https://yandex.st/highlightjs/7.3/languages/r.min.js"></script>-->
  
  <!-- Manific Popup -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/magnific-popup.js/0.8.9/jquery.magnific-popup.min.js"></script>
  
  <script type="text/javascript"
    src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  </script>
  <script defer="defer">
  // Function to generate the dynamic table of contents
  jQuery.fn.generate_TOC = function () {
    var base = $(this[0]);
  
    var selectors = ['h1', 'h2', 'h3', 'h4'];
  
    var last_ptr = [{}, {}, {}, {}];
  
    var anchors = {};
  
    generate_anchor = function (text) {
      var test = text.replace(/\W/g, '_');
  
      while(test in anchors){
        //if no suffix, add one
        if(test.match(/_\d+$/) === null){
          test = test + "_2";
        }
        //else generate unique id for duplicates by adding one to the suffix
        else {
          test = test.replace(/_(\d+)$/, function(match, number){ var num=+number+1; return("_" + num) });
        }
      }
      anchors[test]=1;
      return(test);
    }
  
    $(selectors.join(',')).filter(function(index) { return $(this).parent().attr("id") != 'header'; }).each(function () {
  
      var heading = $(this);
      var idx = selectors.indexOf(heading.prop('tagName').toLowerCase());
      var itr = 0;
  
      while (itr <= idx) {
        if (jQuery.isEmptyObject(last_ptr[itr])) {
          last_ptr[itr] = $('<ul>').addClass('nav');
          if (itr === 0) {
            base.append(last_ptr[itr])
          } else {
            if(last_ptr[itr-1].children('li').length === 0){
              last_ptr[itr-1].append(last_ptr[itr]);
            }
            else {
              last_ptr[itr - 1].children('li').last().append(last_ptr[itr]);
            }
          }
        }
        itr++;
      }
      var anchor = generate_anchor(heading.text());
      heading.attr('id', anchor);
      var a = $('<a>')
      .text(heading.text())
      .attr('href', '#' + anchor);
  
    var li = $('<li>')
      .append(a);
  
    last_ptr[idx].append(li);
    for (i = idx + 1; i < last_ptr.length; i++) {
      last_ptr[i] = {};
    }
    });
  }
  /* run scripts when document is ready */
  $(function() {
    "use strict";
  
    var $window = $(window);
    var $body = $(document.body);
  
    /* size of thumbnails */
  
    var hidden_types = ['source']
    var output_types = ['output', 'message', 'warning', 'error']
  
    /* style tables */
    $('table').addClass('table table-striped table-bordered table-hover table-condensed');
  
    $('pre code').each(function(i, e) {
      hljs.highlightBlock(e);
    });
  
    /* Magnific Popup */
    $(".thumbnail").each(function(){
      $(this).magnificPopup({
        disableOn: 768,
        closeOnContentClick: true,
  
        type: 'image',
        items: {
          src: $(this).find('img').attr('src'),
        }
      });
    });
  
    function toggle_block(obj, show) {
      var span = obj.find('span');
      if(show === true){
        span.removeClass('glyphicon-chevron-up').addClass('glyphicon-chevron-down');
        obj.next('pre').slideDown();
      }
      else {
        span.removeClass('glyphicon-chevron-down').addClass('glyphicon-chevron-up');
        obj.next('pre').slideUp();
      }
    }
  
    function toggle_thumbnails(imgs, show){
      if(show === true){
        imgs.parents().show()
        imgs.slideDown();
      }
      else {
        imgs.slideUp(400, function(){ $(this).parent().hide(); });
      }
    }
  
    function global_toggle(obj){
      var type = obj.attr('type');
      var show = !obj.parent('li').hasClass('active');
      if(show === true){
        obj.parent('li').addClass('active');
      }
      else{
        obj.parent('li').removeClass('active');
      }
      if(type == 'figure'){
        toggle_thumbnails($('.thumbnail img'), show);
      }
      else {
        $('.toggle.' + type).each(function() { toggle_block($(this), show); });
      }
    }
  
    /* onclick toggle next code block */
    $('.toggle').click(function() {
      var span = $(this).find('span');
      toggle_block($(this), !span.hasClass('glyphicon-chevron-down'));
      return false
    })
  
    // global toggles
    $('.toggle-global').click(function(){
      var type = $(this).attr('type');
      if(type === 'all-source'){
          $('li a.source').each(function() {
            global_toggle($(this));
          });
        }
      else if(type === 'all-output'){
        $.each(output_types, function(i, val){
          console.log(val);
          global_toggle($('li a.' + val));
        });
      }
      else {
        console.log($(this));
        global_toggle($(this));
      }
      return false;
    });
    /* table of contents */
    if($(['h1', 'h2', 'h3', 'h4'].join(',')).length > 0){
      $('body > #wrap > .container > .row').append('<div class="col-md-2"><div id="toc" class="well sidebar sidenav affix hidden-print"/></div>');
      $('#toc').generate_TOC();
    }
  
    $.each(hidden_types, function(i, type) {
      $('li[type=' + type + ']').each(function(){ global_toggle($(this)); });
    });
  
    /* remove paragraphs with no content */
    $('p:empty').remove();
  
    $body.scrollspy({
      target: '.sidebar',
    });
  
    /* theme switch */
    $('.theme-switch').click(function(){
      var css = $('link[title=' + $(this).attr('title') + ']');
      $('#theme[rel=stylesheet]').attr('href', css.attr('href'));
      $('.theme-switch').closest('li').removeClass('active');
      $(this).closest('li').addClass('active');
      return false;
    });
    /* code style switch */ //TODO use same function for both of these?
    $('.highlight-switch').click(function(){
      var css = $('link[title="' + $(this).attr('title') + '"]');
      $('#highlight[rel=stylesheet]').attr('href', css.attr('href'));
      $('.highlight-switch').closest('li').removeClass('active');
      $(this).closest('li').addClass('active');
      return false;
    });
  
    //TODO refresh on show/hide
    $window.on('load', function () {
      $body.scrollspy('refresh');
    })
  
  });
  
  </script>
  <style>
  /* Knitr_bootstrap styles */
  #header {
    display: none !important;
    visibility: hidden !important;
  }
  #wrap .container-fluid {
    padding: 0;
    overflow: hidden;
  }
  .toggle{
    text-transform: capitalize;
  }
  
  .toggle-global{
    text-transform: capitalize;
  }
  
  /* Sticky footer styles */
  * {
    margin:0;
  }
  html,
  body {
      height: 100%;
      padding:0 !important;
      /* The html and body elements cannot have any padding or margin. */
      /*overflow-x: hidden;*/
  }
  
  /* Wrapper for page content to push down footer */
  #wrap {
      min-height: 100%;
      height: auto !important;
      height: 100%;
      /* Negative indent footer by it's height */
      margin: 0 auto -120px;
  }
  
  /* Set the fixed height of the footer here */
  #push,
  #footer {
      height: 120px;
  }
  
  #footer {
    text-align: center;
  }
  
  /* Top level subheader elements.  These are the first nested items underneath a header element. */
  .header li {
    font-size: 20px;
  }
  
  /* Makes the font smaller for all subheader elements. */
  .sub-header li {
      font-size: 12px;
  }
  
  button.thumbnails {
    margin-left:0px;
  }
  
  /*
   * Side navigation
   *
   * Scrollspy and affixed enhanced navigation to highlight sections and secondary
   * sections of docs content.
   */
  
  /* By default it's not affixed in mobile views, so undo that */
  .sidebar.affix {
    position: static;
  }
  
  /* First level of nav */
  .sidenav {
    margin-top: 30px;
    margin-bottom: 30px;
    padding-top:    10px;
    padding-bottom: 10px;
    border-radius: 5px;
  }
  
  /* All levels of nav */
  .sidebar .nav > li > a {
    display: block;
    padding: 5px 20px;
  }
  .sidebar .nav > li > a:hover,
  .sidebar .nav > li > a:focus {
    text-decoration: none;
    border-right: 1px solid;
  }
  .sidebar .nav > .active > a,
  .sidebar .nav > .active:hover > a,
  .sidebar .nav > .active:focus > a {
    font-weight: bold;
    background-color: transparent;
    border-right: 1px solid;
  }
  
  /* Nav: second level (shown on .active) */
  .sidebar .nav .nav {
    display: none; /* Hide by default, but at >768px, show it */
    margin-bottom: 8px;
  }
  .sidebar .nav .nav > li > a {
    padding-top:    3px;
    padding-bottom: 3px;
    padding-left: 30px;
    font-size: 90%;
  }
  
  .sidebar .nav .nav .nav > li > a {
    padding-left: 40px;
  }
  .sidebar .nav .nav .nav .nav > li > a {
    padding-left: 50px;
  }
  
  /* Show and affix the side nav when space allows it */
  @media screen and (min-width: 992px) {
    .sidebar .nav > .active > ul {
      display: block;
    }
    /* Widen the fixed sidebar */
    .sidebar.affix,
    .sidebar.affix-bottom {
      width: 213px;
    }
    .sidebar.affix-top,
    .sidebar.affix {
      position: fixed; /* Undo the static from mobile first approach */
      top: 30px;
    }
    .sidebar.affix-bottom {
      position: absolute; /* Undo the static from mobile first approach */
    }
    .sidebar.affix-bottom .sidenav,
    .sidebar.affix .sidenav {
      margin-top: 0;
      margin-bottom: 0;
    }
  }
  @media screen and (min-width: 1200px) {
    /* Widen the fixed sidebar again */
    .sidebar.affix-bottom,
    .sidebar.affix {
      width: 263px;
    }
  }
  
  #toc {
    padding: 10px 0px;
    margin:0;
    border:0;
  }
  
  
  .panel pre {
    margin: 0;
    padding: 0;
    border: 0;
  }
  button + pre {
    margin: 0;
    padding: 0;
  }
  pre code {
    border-radius: 0;
  }
  /* Magnific Popup CSS */
  .mfp-bg {
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 1042;
    overflow: hidden;
    position: fixed;
    background: #0b0b0b;
    opacity: 0.8;
    filter: alpha(opacity=80); }
  
  .mfp-wrap {
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 1043;
    position: fixed;
    outline: none !important;
    -webkit-backface-visibility: hidden; }
  
  .mfp-container {
    text-align: center;
    position: absolute;
    width: 100%;
    height: 100%;
    left: 0;
    top: 0;
    padding: 0 8px;
    -webkit-box-sizing: border-box;
    -moz-box-sizing: border-box;
    box-sizing: border-box; }
  
  .mfp-container:before {
    content: '';
    display: inline-block;
    height: 100%;
    vertical-align: middle; }
  
  .mfp-align-top .mfp-container:before {
    display: none; }
  
  .mfp-content {
    position: relative;
    display: inline-block;
    vertical-align: middle;
    margin: 0 auto;
    text-align: left;
    z-index: 1045; }
  
  .mfp-inline-holder .mfp-content,
  .mfp-ajax-holder .mfp-content {
    width: 100%;
    cursor: auto; }
  
  .mfp-ajax-cur {
    cursor: progress; }
  
  .mfp-zoom-out-cur,
  .mfp-zoom-out-cur .mfp-image-holder .mfp-close {
    cursor: -moz-zoom-out;
    cursor: -webkit-zoom-out;
    cursor: zoom-out; }
  
  .mfp-zoom {
    cursor: pointer;
    cursor: -webkit-zoom-in;
    cursor: -moz-zoom-in;
    cursor: zoom-in; }
  
  .mfp-auto-cursor .mfp-content {
    cursor: auto; }
  
  .mfp-close,
  .mfp-arrow,
  .mfp-preloader,
  .mfp-counter {
    -webkit-user-select: none;
    -moz-user-select: none;
    user-select: none; }
  
  .mfp-loading.mfp-figure {
    display: none; }
  
  .mfp-hide {
    display: none !important; }
  
  .mfp-preloader {
    color: #cccccc;
    position: absolute;
    top: 50%;
    width: auto;
    text-align: center;
    margin-top: -0.8em;
    left: 8px;
    right: 8px;
    z-index: 1044; }
  
  .mfp-preloader a {
    color: #cccccc; }
  
  .mfp-preloader a:hover {
    color: white; }
  
  .mfp-s-ready .mfp-preloader {
    display: none; }
  
  .mfp-s-error .mfp-content {
    display: none; }
  
  button.mfp-close,
  button.mfp-arrow {
    overflow: visible;
    cursor: pointer;
    background: transparent;
    border: 0;
    -webkit-appearance: none;
    display: block;
    padding: 0;
    z-index: 1046;
    -webkit-box-shadow: none;
    box-shadow: none; }
  
  button::-moz-focus-inner {
    padding: 0;
    border: 0; }
  
  .mfp-close {
    width: 44px;
    height: 44px;
    line-height: 44px;
    position: absolute;
    right: 0;
    top: 0;
    text-decoration: none;
    text-align: center;
    opacity: 0.65;
    padding: 0 0 18px 10px;
    color: white;
    font-style: normal;
    font-size: 28px;
    font-family: Arial, Baskerville, monospace; }
    .mfp-close:hover, .mfp-close:focus {
      opacity: 1; }
    .mfp-close:active {
      top: 1px; }
  
  .mfp-close-btn-in .mfp-close {
    color: #333333; }
  
  .mfp-image-holder .mfp-close,
  .mfp-iframe-holder .mfp-close {
    color: white;
    right: -6px;
    text-align: right;
    padding-right: 6px;
    width: 100%; }
  
  .mfp-counter {
    position: absolute;
    top: 0;
    right: 0;
    color: #cccccc;
    font-size: 12px;
    line-height: 18px; }
  
  .mfp-arrow {
    position: absolute;
    opacity: 0.65;
    margin: 0;
    top: 50%;
    margin-top: -55px;
    padding: 0;
    width: 90px;
    height: 110px;
    -webkit-tap-highlight-color: rgba(0, 0, 0, 0); }
  
  .mfp-arrow:active {
    margin-top: -54px; }
  
  .mfp-arrow:hover,
  .mfp-arrow:focus {
    opacity: 1; }
  
  .mfp-arrow:before, .mfp-arrow:after,
  .mfp-arrow .mfp-b,
  .mfp-arrow .mfp-a {
    content: '';
    display: block;
    width: 0;
    height: 0;
    position: absolute;
    left: 0;
    top: 0;
    margin-top: 35px;
    margin-left: 35px;
    border: medium inset transparent; }
  .mfp-arrow:after,
  .mfp-arrow .mfp-a {
    border-top-width: 13px;
    border-bottom-width: 13px;
    top: 8px; }
  .mfp-arrow:before,
  .mfp-arrow .mfp-b {
    border-top-width: 21px;
    border-bottom-width: 21px; }
  
  .mfp-arrow-left {
    left: 0; }
    .mfp-arrow-left:after,
    .mfp-arrow-left .mfp-a {
      border-right: 17px solid white;
      margin-left: 31px; }
    .mfp-arrow-left:before,
    .mfp-arrow-left .mfp-b {
      margin-left: 25px;
      border-right: 27px solid #3f3f3f; }
  
  .mfp-arrow-right {
    right: 0; }
    .mfp-arrow-right:after,
    .mfp-arrow-right .mfp-a {
      border-left: 17px solid white;
      margin-left: 39px; }
    .mfp-arrow-right:before,
    .mfp-arrow-right .mfp-b {
      border-left: 27px solid #3f3f3f; }
  
  .mfp-iframe-holder {
    padding-top: 40px;
    padding-bottom: 40px; }
  
  .mfp-iframe-holder .mfp-content {
    line-height: 0;
    width: 100%;
    max-width: 900px; }
  
  .mfp-iframe-scaler {
    width: 100%;
    height: 0;
    overflow: hidden;
    padding-top: 56.25%; }
  
  .mfp-iframe-scaler iframe {
    position: absolute;
    display: block;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    box-shadow: 0 0 8px rgba(0, 0, 0, 0.6);
    background: black; }
  
  .mfp-iframe-holder .mfp-close {
    top: -40px; }
  
  /* Main image in popup */
  img.mfp-img {
    width: auto;
    max-width: 100%;
    height: auto;
    display: block;
    line-height: 0;
    -webkit-box-sizing: border-box;
    -moz-box-sizing: border-box;
    box-sizing: border-box;
    padding: 40px 0 40px;
    margin: 0 auto; }
  
  /* The shadow behind the image */
  .mfp-figure:after {
    content: '';
    position: absolute;
    left: 0;
    top: 40px;
    bottom: 40px;
    display: block;
    right: 0;
    width: auto;
    height: auto;
    z-index: -1;
    box-shadow: 0 0 8px rgba(0, 0, 0, 0.6);
    background: #444444; }
  
  .mfp-figure {
    line-height: 0; }
  
  .mfp-bottom-bar {
    margin-top: -36px;
    position: absolute;
    top: 100%;
    left: 0;
    width: 100%;
    cursor: auto; }
  
  .mfp-title {
    text-align: left;
    line-height: 18px;
    color: #f3f3f3;
    word-wrap: break-word;
    padding-right: 36px; }
  
  .mfp-figure small {
    color: #bdbdbd;
    display: block;
    font-size: 12px;
    line-height: 14px; }
  
  .mfp-image-holder .mfp-content {
    max-width: 100%; }
  
  .mfp-gallery .mfp-image-holder .mfp-figure {
    cursor: pointer; }
  
  @media screen and (max-width: 800px) and (orientation: landscape), screen and (max-height: 300px) {
    /**
     * Remove all paddings around the image on small screen
     */
    .mfp-img-mobile .mfp-image-holder {
      padding-left: 0;
      padding-right: 0; }
  
    .mfp-img-mobile img.mfp-img {
      padding: 0; }
  
    /* The shadow behind the image */
    .mfp-img-mobile .mfp-figure:after {
      top: 0;
      bottom: 0; }
  
    .mfp-img-mobile .mfp-bottom-bar {
      background: rgba(0, 0, 0, 0.6);
      bottom: 0;
      margin: 0;
      top: auto;
      padding: 3px 5px;
      position: fixed;
      -webkit-box-sizing: border-box;
      -moz-box-sizing: border-box;
      box-sizing: border-box; }
  
    .mfp-img-mobile .mfp-bottom-bar:empty {
      padding: 0; }
  
    .mfp-img-mobile .mfp-counter {
      right: 5px;
      top: 3px; }
  
    .mfp-img-mobile .mfp-close {
      top: 0;
      right: 0;
      width: 35px;
      height: 35px;
      line-height: 35px;
      background: rgba(0, 0, 0, 0.6);
      position: fixed;
      text-align: center;
      padding: 0; }
  
    .mfp-img-mobile .mfp-figure small {
      display: inline;
      margin-left: 5px; } }
  @media all and (max-width: 900px) {
    .mfp-arrow {
      -webkit-transform: scale(0.75);
      transform: scale(0.75); }
  
    .mfp-arrow-left {
      -webkit-transform-origin: 0;
      transform-origin: 0; }
  
    .mfp-arrow-right {
      -webkit-transform-origin: 100%;
      transform-origin: 100%; }
  
    .mfp-container {
      padding-left: 6px;
      padding-right: 6px; } }
  .mfp-ie7 .mfp-img {
    padding: 0; }
  .mfp-ie7 .mfp-bottom-bar {
    width: 600px;
    left: 50%;
    margin-left: -300px;
    margin-top: 5px;
    padding-bottom: 5px; }
  .mfp-ie7 .mfp-container {
    padding: 0; }
  .mfp-ie7 .mfp-content {
    padding-top: 44px; }
  .mfp-ie7 .mfp-close {
    top: 0;
    right: 0;
    padding-top: 0; }
  
  //Magnific overrides
  .mfp-image img{
    background: white;
  }
  .mfp-figure:after {
    background: white;
  }
  
  /*
   * Off Canvas navbar toggle right
   * --------------------------------------------------
   */
  
  @media screen and (max-width: 768px) {
    .row-offcanvas .collapsing {
    -webkit-transition: none 0;
      -moz-transition: none 0;
      transition: none 0;
    }
   .row-offcanvas .navbar {
    position: absolute;
    z-index: 2;
      right:0;
      height:100%;
      width:55px;
      border:0;
      background-color:transparent;
    }
    .row-offcanvas .navbar-toggle {
      margin-right: 5px;
      margin-left: 5px;
    }
    .row-offcanvas {
      position: relative;
    }
    .row-offcanvas-right.active .navbar {
    position: absolute;
    z-index: 2;
      right: -28.4%;
      width:40%;
      background-color:#eee;
      border:0 solid #ddd;
      border-left-width:1px;
    }
    .row-offcanvas-right.active {
      left: -30%;
    }
    .row-offcanvas-right.active .navbar-collapse {
      position: relative;
      width: 100%;
    }
    .row-offcanvas .content {
    /*width:calc(100% - 60px);*/
    }
  }
  </style>
</head>
<body>
<div id="header">
<h1 class="title">mosquitoPoolIndivPaper</h1>
</div>
<div id="wrap">
<div class="container">
<div class="row row-offcanvas row-offcanvas-right">
<div class="contents col-xs-12 col-md-10">
<h1 id="testing-mosquito-samples-for-parasites">Testing mosquito samples for parasites</h1>
<p>African mosquitos Hiseq: ~/SerreDLab-3/raw_reads/2018-08-08_UMB/parsed/DNA<em>R1.fastq.gz - 301bp PE HiSeq ~/SerreDLab-3/raw_reads/2018-04-23_UMB_HNB/parsedMVC/DNA</em>R1.fastq.gz - 251bp PE MiSeq</p>
<p>Traps from DOA ~/SerreDLab-3/raw_reads/2018-08-08_UMB/parsed/DB*R1.fastq.gz - 301bp PE HiSeq</p>
<p>Cambodian mosquitos ~/SerreDLab-3/raw_reads/2017-09-12_UMB/parsedFastqFiles/[FS]*R1.fastq.gz - 251 bp PE HiSeq</p>
<h2 id="load-libraries">Load libraries</h2>
<div class="row">
<button class="source R toggle btn btn-xs btn-primary">
<span class="glyphicon glyphicon-chevron-down"></span> R source
</button>
<pre style=""><code class="source r">library(ggplot2)
library(tidyverse)</code></pre>
<button class="message R toggle btn btn-xs btn-info">
<span class="glyphicon glyphicon-chevron-down"></span> R message
</button>
<pre style=""><code class="message r">## ── Attaching packages ────────────────────────────────── tidyverse 1.2.1 ──
</code></pre>
<button class="message R toggle btn btn-xs btn-info">
<span class="glyphicon glyphicon-chevron-down"></span> R message
</button>
<pre style=""><code class="message r">## ✔ tibble  2.0.1       ✔ purrr   0.3.2  
## ✔ tidyr   0.8.3       ✔ dplyr   0.8.0.1
## ✔ readr   1.3.1       ✔ stringr 1.4.0  
## ✔ tibble  2.0.1       ✔ forcats 0.4.0
</code></pre>
<button class="message R toggle btn btn-xs btn-info">
<span class="glyphicon glyphicon-chevron-down"></span> R message
</button>
<pre style=""><code class="message r">## ── Conflicts ───────────────────────────────────── tidyverse_conflicts() ──
## ✖ dplyr::filter() masks stats::filter()
## ✖ dplyr::lag()    masks stats::lag()
</code></pre>
<button class="source R toggle btn btn-xs btn-primary">
<span class="glyphicon glyphicon-chevron-down"></span> R source
</button>
<pre style=""><code class="source r">#library(reshape2)
#library(plyr)
library(primerTree)</code></pre>
<button class="message R toggle btn btn-xs btn-info">
<span class="glyphicon glyphicon-chevron-down"></span> R message
</button>
<pre style=""><code class="message r">## Loading required package: directlabels
</code></pre>
<button class="message R toggle btn btn-xs btn-info">
<span class="glyphicon glyphicon-chevron-down"></span> R message
</button>
<pre style=""><code class="message r">## Loading required package: gridExtra
</code></pre>
<button class="message R toggle btn btn-xs btn-info">
<span class="glyphicon glyphicon-chevron-down"></span> R message
</button>
<pre style=""><code class="message r">## 
## Attaching package: 'gridExtra'
</code></pre>
<button class="message R toggle btn btn-xs btn-info">
<span class="glyphicon glyphicon-chevron-down"></span> R message
</button>
<pre style=""><code class="message r">## The following object is masked from 'package:dplyr':
## 
##     combine
</code></pre>
<button class="source R toggle btn btn-xs btn-primary">
<span class="glyphicon glyphicon-chevron-down"></span> R source
</button>
<pre style=""><code class="source r">library(ape)
theme_set(theme_bw())
theme_update(plot.title = element_text(hjust = 0.5))</code></pre>
</div>
<h2 id="setup">Setup</h2>
<div class="row">
<button class="source bash toggle btn btn-xs btn-primary">
<span class="glyphicon glyphicon-chevron-down"></span> bash source
</button>
<pre style=""><code class="source bash">mkdir output2
mkdir misc
mkdir makingBarcodeKeyFile
mkdir output2/counts
mkdir output2/trimmed
mkdir output2/noDimers
mkdir output2/noDimers/paired
mkdir output2/fastqc
mkdir output2/primersRemoved
mkdir output2/pandaseqd
mkdir output2/primersRemoved/noShort
mkdir output2/blast
mkdir output2/blast/mergedRaw
mkdir output2/blast/mothured
mkdir output2/blast/inputFiles
mkdir output2/blast/inputFiles/emptyFiles
mkdir output2/blast/output
mkdir output2/blast/output/taxonomy
mkdir output2/blast/output/onTarget
mkdir output2/blast/output/withSeqLen
mkdir output2/primerTree
mkdir output2/primerTree/seqs
mkdir output2/primerTree/taxonomy
</code></pre>
</div>
<h2 id="parse-raw-fastq-files">Parse raw fastq files</h2>
<h3 id="prepare-sample-barcoding-file-for-fastq-parsing">Prepare sample barcoding file for fastq parsing</h3>
<div class="row">

</div>
<div class="row">
<button class="source perl toggle btn btn-xs btn-primary">
<span class="glyphicon glyphicon-chevron-down"></span> perl source
</button>
<pre style=""><code class="source perl">#!/usr/bin/perl
use warnings;
use strict;
use Getopt::Long;
use Pod::Usage;


##############################
# By Matt Cannon
# Date: 
# Last modified: 
# Title: .pl
# Purpose: 
##############################

##############################
# Options
##############################


my $verbose;
my $help;
my $p1;
my $p2;
my $p3;
my $p4;
my $bcInfo;
my $plateMap384 = "";


# i = integer, s = string
GetOptions ("verbose"           => \$verbose,
            "help"              => \$help,
            "P1=s"      => \$p1,
            "P2=s"      => \$p2,
            "P3=s"      => \$p3,
            "P4=s"      => \$p4,
            "barcodes=s"    => \$bcInfo,
        "plateMap384=s"     => \$plateMap384
      )
 or pod2usage(0) && exit;

pod2usage(1) && exit if ($help);


##############################
# Global variables
##############################
my $row = 1;
my %plate;
my %bcHash;

##############################
# Code
##############################


##############################
### Read in plates
### there is probably a smarter way to do than than copying and pasting but meh

#### plate 1 -- row -> X2 -1     column -> X2 - 1
open PLATE1FILE, "$p1" or die "Could not open first plate\nWell, crap\n";
while (my $input = <PLATE1FILE>){
    chomp $input;
    my $plateRow = ($row * 2) - 1;
    my @columns = split "\t", $input;
    for (my $i = 0; $i < scalar(@columns); $i++) {
        my $plateCol = (($i + 1) * 2) - 1;
        $plate{$plateRow}{$plateCol} = $columns[$i];
    }
    $row++;
}
close PLATE1FILE;
$row = 1;

#### plate 2 -- row -> X2 -1     column -> X2
open PLATE2FILE, "$p2" or die "Could not open second plate\nWell, crap\n";
while (my $input = <PLATE2FILE>){
    chomp $input;
    my $plateRow = ($row * 2) - 1;
    my @columns = split "\t", $input;
    for (my $i = 0; $i < scalar(@columns); $i++) {
        my $plateCol = ($i + 1) * 2;
        $plate{$plateRow}{$plateCol} = $columns[$i];
    }
    $row++;
}
close PLATE2FILE;
$row = 1;

#### plate 3 -- row -> X2     column -> X2 - 1
open PLATE3FILE, "$p3" or die "Could not open third plate\nWell, crap\n";
while (my $input = <PLATE3FILE>){
    chomp $input;
    my $plateRow = $row * 2;
    my @columns = split "\t", $input;
    for (my $i = 0; $i < scalar(@columns); $i++) {
        my $plateCol = (($i + 1) * 2) - 1;
        $plate{$plateRow}{$plateCol} = $columns[$i];
    }
    $row++;
}
close PLATE3FILE;
$row = 1;

#### row -> X2     column -> X2
open PLATE4FILE, "$p4" or die "Could not open fourth plate\nWell, crap\n";
while (my $input = <PLATE4FILE>){
    chomp $input;
    my $plateRow = $row * 2;
    my @columns = split "\t", $input;
    for (my $i = 0; $i < scalar(@columns); $i++) {
        my $plateCol = ($i + 1) * 2;
        $plate{$plateRow}{$plateCol} = $columns[$i];
    }
    $row++;
}
close PLATE4FILE;
$row = 1;

##############################
### Read in barcode plate
### 

open BARCODEFILE, "$bcInfo" or die "Could not open barcode file\nWell, crap\n";
while (my $input = <BARCODEFILE>){
    chomp $input;
    my ($rowBcName, $rowBc, $colBcName, $colBc) = split "\t", $input;
    if($row <= 16) {
        $bcHash{row}{$row} = $rowBc;
    }
    $bcHash{column}{$row} = $colBc;
    $row++;
}
close BARCODEFILE;

##############################
### Print out everything
### 
if($plateMap384 ne "") {
    open PLATEMAP384, ">", $plateMap384 or die "Could not write to plateMap384 file\nWell, crap\n";
}


for my $row (1..16) {
    for my $column (1..24) {
        print $plate{$row}{$column}, "\t", $bcHash{column}{$column}, "\t", $bcHash{row}{$row}, "\n";
    if($plateMap384 ne "") {
        print PLATEMAP384 $plate{$row}{$column}, "-", $bcHash{row}{$row}, "-", $bcHash{column}{$column}, "\t";
    }
    }
    print PLATEMAP384 "\n";
}


#open R1OUTFILE, ">", $outputNameStub . "_R1.fastq";

##############################
# POD
##############################

#=pod
    
=head SYNOPSIS

Summary:    
    
    xxxxxx.pl - generates a consensus for a specified gene in a specified taxa
    
Usage:

    perl xxxxxx.pl [options] 


=head OPTIONS

Options:

    --verbose
    --help

=cut</code></pre>
</div>
<div class="row">
<button class="source bash toggle btn btn-xs btn-primary">
<span class="glyphicon glyphicon-chevron-down"></span> bash source
</button>
<pre style=""><code class="source bash">perl ~/SerreDLab-3/cannonm3/scripts/combine4x96wellsTo384withBarcodes.pl \
  --P1 makingBarcodeKeyFile/MVCsamplePlate.txt \
  --P2 makingBarcodeKeyFile/CPsamplePlate.txt \
  --P3 makingBarcodeKeyFile/DBsamplePlate.txt \
  --P4 makingBarcodeKeyFile/emptyPlate.txt \
  --bar makingBarcodeKeyFile/384Plate1barcodes.txt \
  --plateMap makingBarcodeKeyFile/MCDEplateMap.txt \
   > makingBarcodeKeyFile/MCDEPlateSampleKey.txt

cat makingBarcodeKeyFile/MCDEPlateSampleKey.txt makingBarcodeKeyFile/Haikel_HiSeq_BarcodeKey.txt > makingBarcodeKeyFile/allSamplesKey.txt</code></pre>
</div>
<h3 id="parse-out-hiseq-and-miseq-fastq-files">Parse out HiSeq and MiSeq fastq files</h3>
<div class="row">

</div>
<div class="row">
<button class="source perl toggle btn btn-xs btn-primary">
<span class="glyphicon glyphicon-chevron-down"></span> perl source
</button>
<pre style=""><code class="source perl">#!/usr/bin/perl
use warnings;
use strict;
use Getopt::Long;
use Pod::Usage;

##############################
# By Matt Cannon
# Date: 05/10/2017
# Last modified: 05/10/2017
# Title: parseFastqBarcodesDualIndex.pl
# Purpose: Parse fastq files to separate files by barcodes
##############################

##############################
# Options
##############################


my $verbose;
my $help;
my $keyFile;
my $R1;
my $R2;
my $I5;
my $I7;
my $outdir = "parsedFastqFiles";
my $errors = 0;

# i = integer, s = string
GetOptions ("verbose"           => \$verbose,
            "help"              => \$help,
            "keyFile=s"         => \$keyFile,
            "R1=s"              => \$R1,
            "R2=s"              => \$R2,
            "I5=s"              => \$I5,
            "I7=s"              => \$I7,
            "outdir=s"          => \$outdir,
        "errors=i"          => \$errors
            )
or pod2usage(0) && exit;

pod2usage(1) && exit if ($help);

##############################
# Global variables
##############################
my %barcodeHash;
my %barcodeCountHash;
my %outputFileHash;
my $counter = 1;
my $foundCounter = 0;
my %linesToPrint;

##############################
# Code
##############################

##############################
### Let the script read in gzipped files
$R1 =~ s/(.*\.gz)\s*$/gzip -dc < $1|/;
$R2 =~ s/(.*\.gz)\s*$/gzip -dc < $1|/;
$I5 =~ s/(.*\.gz)\s*$/gzip -dc < $1|/;
$I7 =~ s/(.*\.gz)\s*$/gzip -dc < $1|/;

##############################
### Make the output folder

if($verbose) {
    print STDERR "\n\nOutput files will be written to $outdir\n";
    print STDERR "Make sure you have deleted any previously parsed files, as this script will simply append the new parse to the old one\n";
}

mkdir $outdir; #output folder

##############################
### Read in key file and create hash of barcodes with output file as value
### This information should be tab delimited, with sample\tRevComplBarcodeI5\tRevComplBarcodeI7
if($verbose) { 
    print STDERR "Reading key file\n";
}
open KEYFILE, $keyFile or die "Could not open sample-barcode key file\nWell, crap\n";
while (my $input = <KEYFILE>){
    chomp $input;
    my ($sampleID, $barcodeI5, $barcodeI7) = split "\t", $input;
    if($errors > 0) {
    my @I5array = ($barcodeI5);
    my @I7array = ($barcodeI7);
    for(my $i = 0; $i < $errors; $i++) {
        @I5array = oneOff(@I5array);
        @I7array = oneOff(@I7array);
    }

    for my $I5current (@I5array) {
        for my $I7current (@I7array) {
        $barcodeHash{$I5current . $I7current} = $sampleID;
        }
    }
    } else {
    $barcodeHash{$barcodeI5 . $barcodeI7} = $sampleID;
    }
}
close KEYFILE;
$barcodeHash{"unknownunknown"} = "unknownBarcodes";

##############################
### Make up a hash of data to print
if($verbose) { 
    print STDERR "Prepping output files\n";
}

for my $barcode (keys %barcodeHash) {
    @{ $linesToPrint{$barcode}{R1} } = ();
    @{ $linesToPrint{$barcode}{R2} } = ();
}
@{ $linesToPrint{unknownunknown}{R1} } = ();
@{ $linesToPrint{unknownunknown}{R2} } = ();

##############################
### Open the fastq files and print out output files
if($verbose) {
    print STDERR "Parsing fastq files\n";
}

open my $I5FILE, $I5 or die "Could not open I5 file\n";
open my $I7FILE, $I7 or die "Could not open I7 file\n";
open my $R1FILE, $R1 or die "Could not open R1 file\n";
open my $R2FILE, $R2 or die "Could not open R2 file\n";

#Go through the I files and pull in the matching R1 and R2 entries
while (my $iFileLine = <$I5FILE>) { 
    my @i5Lines = getThreeLines($I5FILE); #get the next three I5 lines
    unshift(@i5Lines, $iFileLine); # put all the I5 lines together
    chomp @i5Lines;
    my $I5barcode = $i5Lines[1];
    my @i7Lines = getFastq($I7FILE);
    my $I7barcode = $i7Lines[1];
    my @r1Lines = getFastq($R1FILE);
    my @r2Lines = getFastq($R2FILE);
    if(checkHeaders($i5Lines[0], $i7Lines[0], $r1Lines[0], $r2Lines[0]) == 1) { #Check to be sure that I5, I7, R1 and R2 all are the same read
        print STDERR "Your files are not sorted properly, I need the headers for I5, I7, R1 and R2 to be in an identical order\n";
        die; 
    }
    $r1Lines[0] = join(":", $r1Lines[0], $I5barcode, $I7barcode);
    $r2Lines[0] = join(":", $r2Lines[0], $I5barcode, $I7barcode);
    if(exists($barcodeHash{$I5barcode . $I7barcode})) { #write the read out to a file with the sample name if the barcode exists in the input list
        printLines($I5barcode, $I7barcode, "R1", join("\n", @r1Lines));
        printLines($I5barcode, $I7barcode, "R2", join("\n", @r2Lines));
        $barcodeCountHash{$barcodeHash{$I5barcode . $I7barcode}}++;
    $foundCounter++;
    } else { #write the read out to an "unknownBarcode" file if the barcode is missing from the input list
        printLines("unknown", "unknown", "R1", join("\n", @r1Lines));
        printLines("unknown", "unknown", "R2", join("\n", @r2Lines));
        $barcodeCountHash{unknown}++; 
    }
    if($verbose) {
    if($counter % 10000 == 0) {
        print STDERR commify($counter), " fastq entries processed. ", commify($foundCounter), " barcodes matched                             \r";
    }
    $counter++;
    }
}
print STDERR "Printing out final reads                                  \n";
close $I5FILE;
close $I7FILE;
close $R1FILE;
close $R2FILE;

# Print out the last of the lines
for my $barcode (keys %linesToPrint) {
    if(scalar(@{ $linesToPrint{$barcode}{R1} }) > 0) {
    open OUTPUTR1, '>>', $outdir . "/" . $barcodeHash{$barcode} . "R1.fastq";
    open OUTPUTR2, '>>', $outdir . "/" . $barcodeHash{$barcode} . "R2.fastq";
    print OUTPUTR1 join("\n", @{ $linesToPrint{$barcode}{R1} }),"\n";
    print OUTPUTR2 join("\n", @{ $linesToPrint{$barcode}{R2} }),"\n";
    close OUTPUTR1;
    close OUTPUTR2;
    }
}

if($verbose) {
    print STDERR "Printing out summary log file              \n";
}
# Print out summary
open my $barcodeLogFile, '>', $outdir . "/barcodeSummaryLog.txt";
for my $barcode (sort { $barcodeCountHash{$b} <=> $barcodeCountHash{$a} } keys %barcodeCountHash) {
    if(exists($barcodeHash{$barcode})) {
        print $barcodeLogFile $barcode, "\t", $barcodeHash{$barcode}, "\t", $barcodeCountHash{$barcode}, "\n";
    } else {
        print $barcodeLogFile $barcode, "\tUnknownSample\t", $barcodeCountHash{$barcode}, "\n";
    }
    
}
close $barcodeLogFile;

sub oneOff {
    my @bcArray = @_;
    my @newBCArray = @bcArray;
    my @baseArray = ("A", "T", "C", "G");
    for(my $i = 0; $i < scalar(@bcArray); $i++) {
    for(my $j = 0; $j < length($bcArray[$i]); $j++) {
        my @currentBC = split "", $bcArray[$i];
        for my $base (@baseArray) {
        if($base ne $currentBC[$j]) {
            $currentBC[$j] = $base;
            push @newBCArray, join("", @currentBC);
        }
        }
    }
    }
    return @newBCArray;
}

sub getThreeLines {
    my $fh = shift;
    my @storage;
    for(my $i = 0; $i < 3; $i++){
        my $nextLine = <$fh>;
        push(@storage, $nextLine);
    }
    chomp @storage;
    return @storage;
}

sub getFastq {
    my $fh = shift;
    my @storage;
    for(my $i = 0; $i < 4; $i++) {
        my $nextLine = <$fh>;
        push(@storage, $nextLine);
    }
    chomp @storage;
    return @storage;
}

sub checkHeaders {
    my ($header1, $header2, $header3, $header4) = (@_);
    $header1 =~ s/\s.+//;
    $header2 =~ s/\s.+//;
    $header3 =~ s/\s.+//;
    $header4 =~ s/\s.+//;
    if($header1 ne $header2 | $header1 ne $header3 | $header1 ne $header4) {
        return 1;
    } else {
        return 0;
    }
}

sub printLines {
    my ($I5barcode, $I7barcode, $R1or2, $lines) = (@_);
    push @{ $linesToPrint{$I5barcode . $I7barcode}{$R1or2} }, $lines;
    if(scalar( @{ $linesToPrint{$I5barcode . $I7barcode}{$R1or2} } ) == 10000) {
    open OUTPUT, '>>', $outdir . "/" . $barcodeHash{$I5barcode . $I7barcode} . $R1or2 . ".fastq";
    print OUTPUT join("\n", @{ $linesToPrint{$I5barcode . $I7barcode}{$R1or2} }),"\n";
        @{ $linesToPrint{$I5barcode . $I7barcode}{$R1or2} } = ();
    close OUTPUT;
    }
}

sub commify { # function stolen from web
    my $text = reverse $_[0];
    $text =~ s/(\d\d\d)(?=\d)(?!\d*\.)/$1,/g;
    return scalar reverse $text;
}


##############################
# POD
##############################

=pod

=head NAME

parseFastqBarcodesDualIndex.pl - generates a consensus for a specified gene in a specified taxa

=head SYNOPSIS

perl parseFastqBarcodesDualIndex.pl [options] --keyFile <keyfile.csv> --I5 <I5.fastq.gz> --I7 <I7.fastq.gz> --R1 <R1.fastq.gz> --R2 <R2.fastq.gz>

=head OPTIONS

This script uses I5 and I7 fastq files to parse out R1 and R2 fastq files. A key file is also provided as input. The output is written to 
"parsedFastqFiles/" unless the user provides another output directory. B<Be careful when using this script. If files with the same name are
in the output directory the data will be appended to the end of those files instead of overwriting them. So if you rerun this script you can 
duplicate your reads accidentaly.> 

Options:

=over 4

=item B<--verbose>

    Provide detailed progress summary.

=item B<--help>

    This stuff.

=item B<--keyFile>

    Required. Tab delimited file with three columns. The first is the sample ID. The next two are the I5 and I7 barcodes for that sample. 

=item B<--R1>

    Required. R1 file. Can be gzipped.

=item B<--R2>

    Required. R2 file. Can be gzipped.

=item B<--I5>

    Required. I5 file. Can be gzipped.

=item B<--I7>

    Required. I7 file. Can be gzipped.

=item B<--outdir> ("parsedFastqFiles")

    Output directory. 

=item B<--errors> (0)

    Number of mismatches allowed within each barcode.

=back

=cut</code></pre>
</div>
<div class="row">
<button class="source bash toggle btn btn-xs btn-primary">
<span class="glyphicon glyphicon-chevron-down"></span> bash source
</button>
<pre style=""><code class="source bash">path=~/SerreDLab-3/raw_reads/2018-08-08_UMB

nameStub=AHBGM_20180803_7001153F_IL100105657_S1_L001

perl ~/SerreDLab-3/cannonm3/scripts/fastqTools/parseFastqBarcodesDualIndexTemp.pl \
    -I7  ${path}/${nameStub}_I1.fastq.gz \
    -I5  ${path}/${nameStub}_I2.fastq.gz \
    -R1  ${path}/${nameStub}_R1.fastq.gz \
    -R2  ${path}/${nameStub}_R2.fastq.gz \
    --keyFile makingBarcodeKeyFile/allSamplesKey.txt \
    --errors 0 \
    --outDir ${path}/parsed/
            
parallel -j 5 'gzip {}' ::: ${path}/parsed/*R[12].fastq</code></pre>
</div>
<div class="row">
<button class="source bash toggle btn btn-xs btn-primary">
<span class="glyphicon glyphicon-chevron-down"></span> bash source
</button>
<pre style=""><code class="source bash">path=~/SerreDLab-3/raw_reads/2018-04-23_UMB_HNB

nameStub=AHBGM_20180417_M00708_IL100101409_S1_L001

perl ~/SerreDLab-3/cannonm3/scripts/fastqTools/parseFastqBarcodesDualIndexTemp.pl \
    -I7  ${path}/${nameStub}_RI1.fastq.gz \
    -I5  ${path}/${nameStub}_RI2.fastq.gz \
    -R1  ${path}/${nameStub}_R1.fastq.gz \
    -R2  ${path}/${nameStub}_R2.fastq.gz \
    -v \
    --keyFile makingBarcodeKeyFile/HB_Mosq_screen_Barcode_key.txt \
    --errors 0 \
    --outDir ${path}/parsedMVC/
            
parallel -j 5 'gzip {}' ::: ${path}/parsedMVC/*R[12].fastq</code></pre>
</div>
<div class="row">
<button class="source bash toggle btn btn-xs btn-primary">
<span class="glyphicon glyphicon-chevron-down"></span> bash source
</button>
<pre style=""><code class="source bash">path=~/SerreDLab-3/raw_reads/2017-09-12_UMB

nameStub=MCHB1_20170908_M01994_IL100092583_NoIndex_L001

perl ~/SerreDLab-3/cannonm3/scripts/fastqTools/parseFastqBarcodesDualIndexTemp.pl \
    -I7  ${path}/${nameStub}_R2.fastq.gz \
    -I5  ${path}/${nameStub}_R3.fastq.gz \
    -R1  ${path}/${nameStub}_R1.fastq.gz \
    -R2  ${path}/${nameStub}_R4.fastq.gz \
    --keyFile sampleKey.txt \
    --verbose \
    --errors 0

parallel -j 5 'gzip {}' ::: parsedFastqFiles/*.fastq</code></pre>
</div>
<h3 id="combine-hiseq-and-miseq-runs-by-sample">Combine HiSeq and MiSeq runs by sample</h3>
<div class="row">
<button class="source bash toggle btn btn-xs btn-primary">
<span class="glyphicon glyphicon-chevron-down"></span> bash source
</button>
<pre style=""><code class="source bash">for file in ~/SerreDLab-3/raw_reads/2018-08-08_UMB/parsed/DNA*.fastq.gz
do
  base=${file##*/}
  zcat ~/SerreDLab-3/raw_reads/2018-08-08_UMB/parsed/${base} ~/SerreDLab-3/raw_reads/2018-04-23_UMB_HNB/parsedMVC/${base} | gzip > data/${base}
done</code></pre>
</div>
<h3 id="make-a-list-of-files-from-various-folders">Make a list of files from various folders</h3>
<div class="row">
<button class="source bash toggle btn btn-xs btn-primary">
<span class="glyphicon glyphicon-chevron-down"></span> bash source
</button>
<pre style=""><code class="source bash">ls ~/SerreDLab-3/raw_reads/2017-09-12_UMB/parsedFastqFiles/[FS]*R1.fastq.gz | grep -v "Beam\|BLSA\|DOA\|GA\|GM\|HMB\|KSG\|MTM\|RT1\|TAI\|Tic\|Repeat\|Dug\|Vath\|DVC\|GT" > misc/inputFiles.txt

ls ~/SerreDLab-3/raw_reads/2018-08-08_UMB/parsed/DB*R1.fastq.gz >> misc/inputFiles.txt

ls data/DNA*R1.fastq.gz >> misc/inputFiles.txt</code></pre>
</div>
<h2 id="prepare-the-data-to-blast-and-filter-out-bad-seqs">Prepare the data to BLAST and filter out bad seqs</h2>
<h3 id="run-pandaseq-to-overlap-the-reads">Run pandaSeq to overlap the reads</h3>
<div class="row">
<button class="source bash toggle btn btn-xs btn-primary">
<span class="glyphicon glyphicon-chevron-down"></span> bash source
</button>
<pre style=""><code class="source bash">cat pandaSeq2.sh </code></pre>
<button class="output bash toggle btn btn-xs btn-success">
<span class="glyphicon glyphicon-chevron-down"></span> bash output
</button>
<pre style=""><code class="output bash">#!/bin/bash
#$ -cwd
#$ -P dserre-lab
#$ -o PsQsubStdOut.txt
#$ -e PsQsubStdErr.txt
#$ -l mem_free=5G
#$ -q threaded.q
#$ -pe thread 15
#$ -sync y

parallel -j 10 'name={}; reverse=${name%%R1.fastq.gz}R2.fastq.gz; output=${name%%R1.fastq.gz}.fastq; output=${output##*/}; nice pandaseq -l 100 -t 0.2 -O 600 -F -L 500 -B -T 5 -f {} -r ${reverse} 2> output2/pandaseqd/${output}Log.txt | gzip > output2/pandaseqd/${output}.gz' :::: misc/inputFiles.txt
</code></pre>
</div>
<div class="row">
<button class="source bash toggle btn btn-xs btn-primary">
<span class="glyphicon glyphicon-chevron-down"></span> bash source
</button>
<pre style=""><code class="source bash">qsub pandaSeq2.sh </code></pre>
</div>
<h3 id="cut-primer-sequences-off-of-the-reads-and-put-primer-name-in-fastq-header">Cut primer sequences off of the reads and put primer name in fastq header</h3>
<div class="row">

</div>
<div class="row">
<button class="source perl toggle btn btn-xs btn-primary">
<span class="glyphicon glyphicon-chevron-down"></span> perl source
</button>
<pre style=""><code class="source perl">#!/usr/bin/perl
use strict;
use warnings;
use English;

use Getopt::Long;
use Pod::Usage;


##############################
# By Matt Cannon
# Date:
# Last modified:
# Title: .pl
# Purpose: #this script takes in a list of primers in the format primerName ForwardPrimer ReversePrimer (on each line) and a number denoting how much of the 3' end to use for matching, then it takes in a fastq file and cuts off any primers 
#the program should be run like: perl CutOffSequencFromFastqV1.pl 10 primerlist.txt sampleID-SE[1or2].fastq.gz > output.txt
#the output is a fastq file with the sequence and quality trimmed and the sample ID (from file name) and primer added to the header
#    ## You will want to screen out hits with "noPrimer" in the primer slot of the header afterwards.

##############################

##############################
# Options
##############################


my $verbose;
my $help;
my $lengthOfPrimerToMatch = 15;
my $primerFile;
my $fastqIn;
my $label = "MattRocks";

# i = integer, s = string
GetOptions ("verbose"           => \$verbose,
            "help"              => \$help,
        "matchLen=i"        => \$lengthOfPrimerToMatch,
        "primers=s"         => \$primerFile,
        "fastq=s"           => \$fastqIn,
        "label=s"           => \$label,

      )
 or pod2usage(0) && exit;

pod2usage(1) && exit if ($help);


##############################
# Global variables
##############################

my %primerHash;
my %degeneratehash = ( #hash of arrays - degenerate bases with matching bases
               W => "[AT]",
               S => "[CG]",
               M => "[AC]",
               K => "[GT]",
               R => "[AG]",
               Y => "[CT]",
               B => "[CGT]",
               D => "[AGT]",
               H => "[ACT]",
               V => "[ACG]",
               I => "[ACGT]",
               N => "[ACGT]"
               );


##############################
### Go through the primer, and find any degenerate bases
### and replace with regex

if($verbose) {
    print STDERR "Parsing primer input\n";
}

open PRIMERFILE, "$primerFile" or die "$OS_ERROR Could not open primer input\nWell, crap\n";
while (my $input = <PRIMERFILE>){
    chomp $input;
    my ($primerName, $primerF, $primerR) = split " ", $input;
    dealWithDegenerates($primerF, $primerName);
    dealWithDegenerates($primerR, $primerName);
}

sub dealWithDegenerates {
    my $primer = $_[0];
    my $primerName = $_[1];

    my $primerLength = length($primer);

    # trim primer
    if(length($primer) > $lengthOfPrimerToMatch) {
    $primer = substr($primer, 0, $lengthOfPrimerToMatch);
    }

    if($primer =~ /[WSMKRYBDHVIN]/) { #if the primer has any degenerate bases, deconvolute those and add the subsequent primers to the hash
    my @primerArray = split "", $primer; #make an array containing the degenerate primer
    for(my $i = 0; $i < scalar(@primerArray); $i++) { # sort through primerArray
        if($primerArray[$i] =~ /[WSMKRYBDHVIN]/) { 
        $primerArray[$i] = $degeneratehash{$primerArray[$i]};
        } 
    }
    $primer = join("", @primerArray);
    }
    $primerHash{$primer}{primerName} = $primerName;
    $primerHash{$primer}{length} = $primerLength;
}

if($verbose) {
    for my $primerSeq (keys %primerHash) {
    print STDERR join("\t", $primerSeq, $primerHash{$primerSeq}{primerName}, $primerHash{$primerSeq}{length}) . "\n";
    }
}

close PRIMERFILE;

##############################
### Now, pull in the fastq 

$fastqIn =~ s/(.*\.gz)\s*$/gzip -dc < $1|/;

my $line = 1;
my $storage;

open FASTQINPUTFILE, "$fastqIn" or die "$OS_ERROR Could not open fastq input\nWell, crap\n";
while (my $input = <FASTQINPUTFILE>){
    chomp $input;
    if($line == 1) {
    $storage = $input;
    } elsif($line < 4) {
    $storage = join("\t", $storage, $input);
    } elsif($line == 4) {
    $storage = join("\t", $storage, $input);
    trimSequence($storage);
    $line = 0;
    }
    $line++;
}

sub trimSequence {
    my $fastq = shift;
    my ($header, $sequence, $header2, $quality) = split "\t", $fastq;
    my @trimmedSeqPrimerQual = searchSequenceForPrimer($sequence, $quality);
    my $newHeader = $header;
    $newHeader = $newHeader . "|" . $trimmedSeqPrimerQual[1] . "|" . $label;
    my $newfastq = join("\n", $newHeader, $trimmedSeqPrimerQual[0], "+", $trimmedSeqPrimerQual[2]);
    print $newfastq, "\n";
}

sub searchSequenceForPrimer {
    my $sequence = shift;
    my $qual = shift;
    my $trimSeq;
    my $trimQual;
    my $primerHit = "noPrimer";
    my @returnValue; 
    for my $primerSeq (keys %primerHash) {
    my $revCompSeq = revComp($sequence);
    if($sequence =~ /^$primerSeq/) {
        $trimSeq = substr($sequence, $primerHash{$primerSeq}{length});
        $trimQual = substr($qual, $primerHash{$primerSeq}{length});
        $sequence = $trimSeq;
        $qual = $trimQual;
        $primerHit = $primerHash{$primerSeq}{primerName};
        
    } elsif($revCompSeq =~ /^$primerSeq/) {
        $trimSeq = substr($sequence, 0, -1 * $primerHash{$primerSeq}{length});
        $trimQual = substr($qual, 0, -1 * $primerHash{$primerSeq}{length});
        $sequence = $trimSeq;
        $qual = $trimQual;
        $primerHit = $primerHash{$primerSeq}{primerName};
    }
    }
    @returnValue = ($sequence, $primerHit, $qual);
    return @returnValue;
}

sub revComp{
    my $seq = shift;
    $seq =~ tr/ACGTacgt/TGCAtgca/;
    reverse($seq);
}</code></pre>
</div>
<div class="row">
<button class="source bash toggle btn btn-xs btn-primary">
<span class="glyphicon glyphicon-chevron-down"></span> bash source
</button>
<pre style=""><code class="source bash">parallel -j 5 'label={}; label=${label##*/}; label=${label%_.fastq.gz}; perl ~/SerreDLab-2/cannonm3/scripts/CutOffSequenceFromFastqV3.pl --matchLen 15 --primers misc/primerKey.txt --fastq {} --label ${label}  | gzip > output2/primersRemoved/${label}.fastq.gz' ::: output2/pandaseqd/*fastq.gz  </code></pre>
</div>
<h3 id="filter-out-the-short-sequences">Filter out the short sequences</h3>
<div class="row">

</div>
<div class="row">
<button class="source perl toggle btn btn-xs btn-primary">
<span class="glyphicon glyphicon-chevron-down"></span> perl source
</button>
<pre style=""><code class="source perl">#!usr/bin/perl
use strict;
use warnings;
use English;

#this script takes in a fastq file and removes any entries where the sequnce length is less than the given cutoff 
##usage should be perl filterShortFastq.pl 50 file_SE1.fastq.gz 


my $line =1;
my $storage;

my $minLength = shift;

while (my $input = <>){
    chomp $input;
    if($line==1) {
        $storage=$input;
    } elsif($line<4) {
        $storage = join("\n",$storage, $input);
    } elsif($line==4) {
        $storage = join("\n",$storage, $input);
        printGoodLines($storage);
        $line=0;
    }
    $line++;
}


sub printGoodLines {
    my $fastq = shift;
    my ($header, $sequence, $header2,$quality) = split "\n", $fastq;
    if(length($sequence)>=$minLength) {
        print $fastq, "\n";
    }
}

exit;</code></pre>
</div>
<div class="row">
<button class="source bash toggle btn btn-xs btn-primary">
<span class="glyphicon glyphicon-chevron-down"></span> bash source
</button>
<pre style=""><code class="source bash">parallel -j 5 'zcat {} | perl ~/SerreDLab-2/cannonm3/scripts/filterShortFastq.pl 100 | gzip > output2/primersRemoved/noShort/{/}' ::: output2/primersRemoved/*fastq.gz   </code></pre>
</div>
<h3 id="put-all-the-fasta-files-together-into-files-by-primer">Put all the fasta files together into files by primer</h3>
Add the sample name to the file and combine.
<div class="row">
<button class="source bash toggle btn btn-xs btn-primary">
<span class="glyphicon glyphicon-chevron-down"></span> bash source
</button>
<pre style=""><code class="source bash">for primer in \
    Apicomp18S_365-613 \
    Eimeriorina18S_302-730 \
    FlaviallS_FlaviallAS2 \
    Kineto_18S4 \
    Microsporidia_18S \
    Parab18S_288-654 \
    Plasmo18S_883-1126 \
    Platy_18S3 \
    Spirur18S_1435-1858 \
    Spirurida_18S2 \
    Tricho_18S2
do
  zcat output2/primersRemoved/noShort/*.fastq.gz | grep -A 1 $primer \
    | grep -v "^--" | perl -pe 's/\t/:/' | \
    perl -pe 's/\@HWI-M01/>HWI-M01/' | \
    perl -pe 's/\@M00708/>M00708/' | \
    perl -pe 's/\@70011/>70011/' \
    > output2/blast/mergedRaw/merged_products_${primer}.fa &
done</code></pre>
</div>
<h3 id="get-unique-sequences">Get unique sequences</h3>
<div class="row">

</div>
<div class="row">
<button class="source perl toggle btn btn-xs btn-primary">
<span class="glyphicon glyphicon-chevron-down"></span> perl source
</button>
<pre style=""><code class="source perl">#!/usr/bin/perl
use strict;
use warnings;

local $/ = "\n>"; #change the input delimiter to > so the script pulls in the whole fasta entry

#This script takes in fasta files and keeps one unique sequence 
#Outputs files identical to Mothur's unique.seqs: .names and .unique.fasta

my %storageHash;
my %headerStorage;
my $counter=0;
my $uniqueCounter=0;

my $FileName = shift;

if($FileName eq "--help") { #ha!
    die "What, do you need me to hold your hand?!?!?!?!\nJust give me a damn fasta file!\n";
} elsif($FileName eq "--version") {
    die "It's rude to ask someone's age.\n"
}

open FILE, "$FileName" or die "Could not open $FileName\nWell, crap.....\n";

while(my $file = <FILE>){
    $counter++;
    chomp $file;
    my ($header,$seq)=split "\n", $file,2;
    $header =~ s/^>//;
    die "Duplicate fasta headers detected\n" if exists($headerStorage{$header});
    $headerStorage{$header}=1;
    $seq =~ s/\n//g; #get rid of extra newlines in sequence
    if( !exists($storageHash{$seq}) & !exists($storageHash{revcomp($seq)}) ) { 
    $storageHash{$seq}=$header;
    $uniqueCounter++;
    } elsif( exists($storageHash{$seq}) ) {
    $storageHash{$seq}=join("\t",$storageHash{$seq},$header);
    } elsif( exists( $storageHash{revcomp($seq)} ) ) {
    $storageHash{$seq}=join("\t",$storageHash{revcomp($seq)},$header);
    }
    #print STDERR "\e[JSequences analyzed:\t",commify($counter),"\tUnique Sequences:\t",commify($uniqueCounter),"\r";
}

$FileName =~ s/\.fasta//;
$FileName =~ s/\.fa//;
open my $fastaOutputFile, ">", join(".",$FileName,"unique.fasta");
open my $namesOutputFile, ">", join(".",$FileName,"names");

#print STDERR "Printing output\n";

for my $sequence (keys %storageHash) {
    my $firstHeader = $storageHash{$sequence};
    $firstHeader =~ s/\t.+//;
    print $fastaOutputFile ">",$firstHeader,"\n",$sequence,"\n";
    print $namesOutputFile $firstHeader,"\t", join(",", split("\t", $storageHash{$sequence}) ),"\n";
}

#print STDERR "Done!\nSequences analyzed:\t",commify($counter),"\tUnique Sequences:\t",commify($uniqueCounter),"\n";

sub revcomp {
    my $seq = shift;
    $seq =~ tr/ATGCatgc/TACGtacg/;
    my $seqOut = reverse($seq);
    return $seqOut;
}

sub commify {
    my $text = reverse $_[0];
    $text =~ s/(\d\d\d)(?=\d)(?!\d*\.)/$1,/g;
    return scalar reverse $text
}</code></pre>
</div>
<div class="row">
<button class="source bash toggle btn btn-xs btn-primary">
<span class="glyphicon glyphicon-chevron-down"></span> bash source
</button>
<pre style=""><code class="source bash">parallel -j 5 'perl ~/SerreDLab-2/cannonm3/scripts/mattsMothur.pl {}' ::: output2/blast/mergedRaw/*.fa</code></pre>
</div>
<div class="row">
<button class="source bash toggle btn btn-xs btn-primary">
<span class="glyphicon glyphicon-chevron-down"></span> bash source
</button>
<pre style=""><code class="source bash">parallel -j 5 'gzip -f {}' ::: output2/blast/mergedRaw/merged_products*.names
parallel -j 5 'gzip -f {}' ::: output2/blast/mergedRaw/merged_products*.unique.fasta
parallel -j 5 'gzip -f {}' ::: output2/blast/mergedRaw/merged_products*.fa</code></pre>
</div>
<h3 id="filter-out-any-sequences-seen-less-than-10-times">Filter out any sequences seen less than 10 times</h3>
<div class="row">

</div>
<div class="row">
<button class="source perl toggle btn btn-xs btn-primary">
<span class="glyphicon glyphicon-chevron-down"></span> perl source
</button>
<pre style=""><code class="source perl"></code></pre>
</div>
<div class="row">
<button class="source bash toggle btn btn-xs btn-primary">
<span class="glyphicon glyphicon-chevron-down"></span> bash source
</button>
<pre style=""><code class="source bash">parallel -j 5 'name={}; base=${name%names.gz}; perl ~/SerreDLab-2/cannonm3/scripts/filterMothurByCountV2.pl --cutoff 10 --names {} --fasta ${base}unique.fasta.gz --out output2/blast/inputFiles/${base##*/}' ::: output2/blast/mergedRaw/merged_products*.names.gz

#writes out two files: output2/blast/inputFiles/merged_products*Filtered.names         
#                      output2/blast/inputFiles/merged_products*Unique.filtered.fa</code></pre>
</div>
<h2 id="blast">Blast</h2>
<p>The filter environmental samples option on online blast using the Entrez query <code>all [filter] NOT(environmental samples[organism] OR metagenomes[orgn] OR txid32644[orgn])</code> to remove uncultured samples. In order to reproduce this I downloaded all the gi’s for the query <code>all [filter] NOT(environmental samples[organism] OR metagenomes[orgn] OR txid32644[orgn])</code> using a browser and put them in <code>data/uncultured_samples.gi.gz</code>. The gi’s are then filtered out using the -negative_gilist option.</p>
<div class="row">
<button class="source bash toggle btn btn-xs btn-primary">
<span class="glyphicon glyphicon-chevron-down"></span> bash source
</button>
<pre style=""><code class="source bash">cat blast3.sh</code></pre>
<button class="output bash toggle btn btn-xs btn-success">
<span class="glyphicon glyphicon-chevron-down"></span> bash output
</button>
<pre style=""><code class="output bash">#!/bin/bash
#$ -cwd
#$ -P dserre-lab
#$ -o blastQsubStdOut.txt
#$ -e blastQsubStdErr.txt
#$ -l mem_free=10G
#$ -q threaded.q
#$ -pe thread 30
#$ -N blast
#$ -sync y
#$ -t 1-11
#$ -tc 5


fileList=(output2/blast/inputFiles/merged_products_*.fa)

for i in "${!fileList[@]}"; do 
  fileList[$i]="${fileList[$i]##*/}"
done

/usr/local/packages/ncbi-blast+-2.7.1/bin/blastn \
      -task blastn \
      -negative_gilist ~/SerreDLab-3/cannonm3/unculturedOrgs_8_16_18.gi \
      -db ~/SerreDLab-3/databases/blast/nt \
      -query output2/blast/inputFiles/${fileList[${SGE_TASK_ID} - 1]} \
      -num_threads 29 \
      -outfmt "7 qseqid sgi pident length mismatch gapopen qstart qend sstart send evalue bitscore" \
    | gzip \
    > output2/blast/output/${fileList[${SGE_TASK_ID} - 1]%Unique.filtered.fa}blastResults2.txt.gz
</code></pre>
</div>
<div class="row">
<button class="source bash toggle btn btn-xs btn-primary">
<span class="glyphicon glyphicon-chevron-down"></span> bash source
</button>
<pre style=""><code class="source bash">qsub blast3.sh</code></pre>
</div>
<h2 id="parse-out-blast-results">Parse out BLAST results</h2>
<h3 id="parse-out-blast-results-using-the-.names-file">Parse out blast results using the .names file</h3>
<div class="row">

</div>
<div class="row">
<button class="source perl toggle btn btn-xs btn-primary">
<span class="glyphicon glyphicon-chevron-down"></span> perl source
</button>
<pre style=""><code class="source perl">#!/usr/bin/perl
use warnings;
use strict;
use English;

##format should be perl parseBlastWithNameFile.pl file.names file.blast.tab.gz > outputfile.txt

my %readNameHash;
my %readLengthHash;
my $newRead;
my $maxBitscore;

@ARGV = map { s/(.*\.gz)\s*$/gzip -dc < $1|/;$_ } @ARGV;

my $inputFileName = shift;
open INPUTFILE, "$inputFileName" or die "$OS_ERROR Could not open first input\nWell, crap\n";
while (my $input = <INPUTFILE>){
    chomp $input;
    countReadsPerLine($input);
}
close INPUTFILE;

$inputFileName = shift;
open INPUTFILE, "$inputFileName" or die "$OS_ERROR Could not open first input\nWell, crap\n";
local $/ = "\n>"; #change the input delimiter to > so the script pulls in the whole fasta entry
while (my $input = <INPUTFILE>){
    chomp $input;
    my ($readName, $sequence) = split "\n", $input;
    $readName =~ s/>//;
    $readName =~ s/:1\|.+/:1/; # cut off sample info
    $readLengthHash{$readName} = length($sequence);
}
close INPUTFILE;

local $/ = "\n";
print "#primerSample\tcount\tgi\tblastedReadName\tidentity\talignmentlength\tmismatches\tgapopens\tqstart\tqend\tsstart\tsend\tevalue\tbitscore","\n"; #header

my $inputFile2Name = shift;
open INPUTFILE2, "$inputFile2Name" or die "$OS_ERROR Could not open second input\nWell, crap\n";
while (my $input = <INPUTFILE2>){
    chomp $input;
    goThroughBlast($input);
}
close INPUTFILE2;

sub countReadsPerLine {
    my ($firstRead, $theRest) = split "\t", $_[0];
    $firstRead =~ s/:1\|.+/:1/;
    my @readNameArray = split ",", $theRest;
    for(@readNameArray) {
        s/^.+?\|//;
    } 
    for(my $i = 0; $i < @readNameArray; $i++){
        $readNameHash{$firstRead}{$readNameArray[$i]}++;
    }
}

sub goThroughBlast {
    if($_[0] =~ /^\#/){
        $newRead = 1;
    } else {
        processBlast($_[0]);
    }
}

sub processBlast {
    if($newRead == 1) {
        processFirstRead($_[0]);
    } else {
        processOtherReads($_[0]);
    }
}

sub processFirstRead {
    my ($queryid, $subjectid, $identity, $alignmentlength, $mismatches, $gapopens, $qstart, $qend, $sstart, $send, $evalue, $bitscore) = split "\t", $_[0];
    $maxBitscore = $bitscore;
    $queryid =~ s/:1\|.+/:1/;
    $subjectid =~ s/gi\|//;
    $subjectid =~ s/\|.+//;
    $identity = ((($qend - $qstart +1) - $mismatches - $gapopens)/ $readLengthHash{$queryid}) * 100;
    printHit($queryid, $subjectid, join("\t", $identity, $alignmentlength, $mismatches, $gapopens, $qstart, $qend, $sstart, $send, $evalue, $bitscore)); 
    $newRead = 0;
}

sub processOtherReads {
    my ($queryid, $subjectid, $identity, $alignmentlength, $mismatches, $gapopens, $qstart, $qend, $sstart, $send, $evalue, $bitscore) = split "\t", $_[0];
    if($bitscore == $maxBitscore) {
    $queryid =~ s/:1\|.+/:1/;
    $subjectid =~ s/gi\|//;
    $subjectid =~ s/\|.+//;
    $identity = ((($qend - $qstart +1) - $mismatches - $gapopens)/ $readLengthHash{$queryid}) * 100;
    printHit($queryid, $subjectid, join("\t", $identity, $alignmentlength, $mismatches, $gapopens, $qstart, $qend, $sstart, $send, $evalue, $bitscore)); 
    }
}

sub printHit {
    for my $primerSample (keys %{$readNameHash{$_[0]}}) {
        print join("\t", $primerSample, $readNameHash{$_[0]}{$primerSample}, $_[1], $_[0], $_[2]) . "\n";
    }
}</code></pre>
</div>
<div class="row">
<button class="source bash toggle btn btn-xs btn-primary">
<span class="glyphicon glyphicon-chevron-down"></span> bash source
</button>
<pre style=""><code class="source bash">fileList=(output2/blast/output/*.blastResults2.txt.gz)

for i in "${!fileList[@]}"
do 
  fileList[$i]="${fileList[$i]##*/merged_products_}"
  fileList[$i]="${fileList[$i]%.blastResults2.txt.gz}"
done

parallel -j 5 'perl ~/SerreDLab-2/cannonm3/scripts/parseBlastWithNameFileSummaryStats6.2.pl output2/blast/inputFiles/merged_products_{}.Filtered.names output2/blast/inputFiles/merged_products_{}.Unique.filtered.fa output2/blast/output/merged_products_{}.blastResults2.txt.gz | gzip > output2/blast/output/blastGICountsStats_{}.txt.gz' ::: ${fileList[@]}

#make up list of unique gis
parallel -j 5 'zcat output2/blast/output/blastGICountsStats_{}.txt.gz | cut -f 3 | sort | uniq | grep -v ^gi$ > output2/blast/output/taxonomy/gis_{}.txt' ::: ${fileList[@]}</code></pre>
</div>
<h3 id="get-taxonomy-using-perl-ripoff-of-jims-primertree-get_taxonomy-function">Get taxonomy using perl ripoff of Jim’s primerTree get_taxonomy function</h3>
<div class="row">

</div>
<div class="row">
<button class="source perl toggle btn btn-xs btn-primary">
<span class="glyphicon glyphicon-chevron-down"></span> perl source
</button>
<pre style=""><code class="source perl">#!/usr/bin/perl
use warnings;
use strict;
use Getopt::Long;
use Pod::Usage;
use XML::Simple;
use Data::Dumper;

##############################
# By Matt Cannon
# Date: 
# Last modified: 
# Title: .pl
# Purpose: 
##############################

##############################
# Options
##############################


my $verbose;
my $help;
my $gis;
my $taxids;
my $ranks = "kingdom, phylum, class, order, family, genus";
my $queryNum = 100;
my $debug;
my $apiKey;

###############################################################################
###  Edit out my api key before I push this to github 
################################################################################

# i = integer, s = string
GetOptions ("verbose"           => \$verbose,
            "help"              => \$help,
            "gis=s"     => \$gis,
        "taxids=s"          => \$taxids,
        "ranks=s"           => \$ranks,
        "queryNum=i"        => \$queryNum,
        "apiKey=s"          => \$apiKey,
        "debug"             => \$debug
      )
 or pod2usage(0) && exit;

pod2usage(1) && exit if ($help);


##############################
# Global variables
##############################
my $gi2tax = "https://eutils.ncbi.nlm.nih.gov/entrez/eutils/elink.fcgi?dbfrom=nuccore&db=taxonomy&id="; #type=acc&id="; # need to add option to provide accession numbers and then direct eutils to return accession numbers
my $taxQuery = "https://eutils.ncbi.nlm.nih.gov/entrez/eutils/efetch.fcgi?db=taxonomy&retmode=xml&id=";
my @classesToGet;
my @giList;
my @taxidList;
my %taxidHash;
my %gi2TaxHash;
my %taxaHash;
my $counter = 1;

##############################
# Code
##############################

##############################
### Add api_key if provided
if($apiKey) {
    my $fromRegex = '&id=';
    my $toRegex = '&api_key=' . $apiKey . '&id=';
    $gi2tax =~ s/$fromRegex/$toRegex/;
    $taxQuery =~  s/$fromRegex/$toRegex/;
    #print STDERR $gi2tax, "\n", $taxQuery, "\n";
}

##############################
### Convert gi to taxid

$ranks =~ s/\s//g;
$ranks = lc($ranks);
@classesToGet = split(",", $ranks);

if($gis) {
    open my $giFH, "$gis" or die "Could not open gis input\nWell, crap\n";
    while (my $gi = <$giFH>){
    chomp $gi;
    push @giList, $gi;
    }
    print "gi\tspecies\t", join "\t", @classesToGet, "\n";
} elsif($taxids) {
    open my $taxaFH, "$taxids" or die "Could not open taxid input\nWell, crap\n";
    while (my $taxa = <$taxaFH>){
    chomp $taxa;
    push @taxidList, $taxa;
    }    
    print "taxid\tspecies\t", join "\t", @classesToGet, "\n";
} else {
    print STDERR "Must provide input to either --gis or --taxids\n\n";
    die;
}
    
while(scalar(@giList) > 0) {
    my @gisToQuery;
    @gisToQuery = splice @giList, 0, $queryNum;

    if($verbose) {
    my $oldCounter = $counter; 
        $counter += scalar(@gisToQuery);
        print STDERR "Finding taxids for gis#", $oldCounter, "through ", $counter - 1, "\n";
    }

    if($verbose) {
    print STDERR "Submitting gi to taxid query to NCBI\n";
    }

    my $gi2taxSearch = "GET \"" . $gi2tax . join("&id=", @gisToQuery) . "\"";
    my $gi2taxResponse = `$gi2taxSearch`;
    print STDERR "gi2taxSearch: ", $gi2taxSearch, "\n", if($debug);
    print STDERR $gi2taxResponse, "\n", if($debug);
    if($verbose) {
    print STDERR "Query retrieved\nParsing\n";
    }

    if($gi2taxResponse !~ /ERROR/) { # need to check for excessive query errors needing api key
    my $giXML = XMLin($gi2taxResponse, forceArray => ['LinkSet', 'Link']);
    for(my $i = 0; $i < scalar(@{ $giXML->{LinkSet} }); $i++) {
        my $giNum = $giXML->{LinkSet}[$i]{IdList}{Id};
        my $taxId = $giXML->{LinkSet}[$i]{LinkSetDb}{Link}[0]{Id}; 
                # In cases where there are two taxids listed, keep the first. 
            # This is rare and annoying when it happens. I may change the behaviour
            # in the future to output all taxa info for each gi.
        if(defined($taxId)) {
        $gi2TaxHash{$giNum} = $taxId;
        $taxidHash{$taxId} = 1;
        } else {
        print STDERR "Gi# ", $giNum, " has no available taxonomy\n";
        }
    }
    } else {
    print STDERR "Error in gi2tax id query\n";
    print STDERR $gi2taxSearch, "\n";
    print STDERR Dumper($gi2taxResponse), "\n";
    die;
    }
}

if($verbose) {
    print STDERR "Getting taxa info using taxids\n";
}

# Reset counter
$counter = 1;

# make @taxidList if gis were provided
if($gis) {
    @taxidList = keys(%taxidHash);
}

# Get taxonomy info using @taxidList
while(scalar(@taxidList) > 0) {
    print STDERR "\@taxidList contents: ", join("\t", @taxidList), "\n", if($debug);

    my @taxidsToQuery;
    @taxidsToQuery = splice @taxidList, 0, $queryNum;

    if($verbose) {
    my $oldCounter = $counter; 
        $counter += scalar(@taxidsToQuery);
        print STDERR "Finding taxonomy for taxids#", $oldCounter, "through ", $counter - 1, "\n";
    }

    if($verbose) {
    print STDERR "Submitting taxonomy query to NCBI\n";
    }

    my $taxSearch = "GET \"" . $taxQuery . join("&id=", @taxidsToQuery) . "\"";

    print STDERR "taxSearch contents: ", $taxSearch, "\n", if ($debug);

    if($verbose) {
    print STDERR "Query retrieved\nParsing\n";
    }

    my $taxResponse = `$taxSearch`;
    if($taxResponse !~ /ERROR/) {
    my $taxaXML = XMLin($taxResponse, forceArray => ['Taxon']);
    print Dumper($taxaXML), if ($debug); 
    #die;
    for(my $i = 0; $i < scalar(@{ $taxaXML->{Taxon} }); $i++) {
        my $taxId = $taxaXML->{Taxon}[$i]{TaxId};
        for(my $j = 0; $j < scalar(@{ $taxaXML->{Taxon}[$i]{LineageEx}{Taxon} }); $j++) {
        $taxaHash{$taxId}{species} = $taxaXML->{Taxon}[$i]{ScientificName};
        for my $rank (@classesToGet) {
            if($rank eq $taxaXML->{Taxon}[$i]{LineageEx}{Taxon}[$j]{Rank}) {
            $taxaHash{$taxId}{$rank} = $taxaXML->{Taxon}[$i]{LineageEx}{Taxon}[$j]{ScientificName};
            }
        }
        }
    }
    } else {
    print STDERR "Error in taxa query\n";
    print $taxResponse, "\n";
    die;
    }

}


if($verbose) {
    print STDERR "Printing results\n";
}


if($gis) {
    for my $giNum (keys %gi2TaxHash) {
    my $taxId = $gi2TaxHash{$giNum};
    if(exists($taxaHash{$taxId})) {
        print $giNum;
        print "\t", $taxaHash{$taxId}{species};
        for my $rank (@classesToGet) {
        if(exists($taxaHash{$taxId}{$rank})) {
            print "\t", $taxaHash{$taxId}{$rank};
        } else {
            print "\tNA";
        }
        }
        print "\n";
    }
    }
} else {
    for my $taxId (keys %taxaHash) {
    print $taxId;
    print "\t", $taxaHash{$taxId}{species};
    for my $rank (@classesToGet) {
        if(exists($taxaHash{$taxId}{$rank})) {
        print "\t", $taxaHash{$taxId}{$rank};
        } else {
        print "\tNA";
        }
    }
    print "\n";
    }
}

exit;

##############################
# POD
##############################

#=pod
    
=head SYNOPSIS

Summary:    
    
    getTaxa.pl - get taxonomy information for provided GIs
    
Usage:

    perl getTaxa.pl [options] --input giList.txt 


=head OPTIONS

Options:

    --verbose
    --help
    --gis
       Single column of gis
    --taxids
       Single column of taxids
    --ranks
       List of ranks, separated by commas, all in a single quote
             for example: --ranks "superkingdom, kingdom, phylum, class, order, family, genus"
    --queryNum
       Number of gis to query at once. Probably don't need to change this

=cut</code></pre>
</div>
<div class="row">
<button class="source bash toggle btn btn-xs btn-primary">
<span class="glyphicon glyphicon-chevron-down"></span> bash source
</button>
<pre style=""><code class="source bash">fileList=(output2/blast/output/*.blastResults2.txt.gz)

for i in "${!fileList[@]}"
do
  fileList[$i]="${fileList[$i]##*/merged_products_}"
  fileList[$i]="${fileList[$i]%.blastResults2.txt.gz}"
done

parallel -j 2 'perl ~/SerreDLab-3/cannonm3/scripts/getTaxa/getTaxa.pl --api 4da437af9f4a6d26e1fb51be8d57af1e1009 -q 200 --gis output2/blast/output/taxonomy/gis_{}.txt > output2/blast/output/taxonomy/blastTaxaRaw_{}.txt 2> output2/blast/output/taxonomy/{}log.txt' ::: ${fileList[@]}</code></pre>
</div>
<h4 id="get-rid-of-in-taxa-names">Get rid of “/” in taxa names</h4>
<div class="row">
<button class="source bash toggle btn btn-xs btn-primary">
<span class="glyphicon glyphicon-chevron-down"></span> bash source
</button>
<pre style=""><code class="source bash">fileList=(output2/blast/output/taxonomy/blastTaxaRaw_*.txt)

for i in "${!fileList[@]}"
do
  fileList[$i]="${fileList[$i]%.txt}"
done

parallel -j 5 'perl -pe "s/\//_/g" {}.txt > {}Fixed.txt' ::: ${fileList[@]} 
</code></pre>
</div>
<h3 id="combine-the-gi-read-count-data-with-taxa-information-but-include-full-taxonomy">Combine the GI read count data with taxa information, but include full taxonomy</h3>
<div class="row">

</div>
<div class="row">
<button class="source perl toggle btn btn-xs btn-primary">
<span class="glyphicon glyphicon-chevron-down"></span> perl source
</button>
<pre style=""><code class="source perl">#!/user/bin/perl
use strict;
use warnings;
use English;

###this script takes files and combines them by the first X tab separated columns.
###the first file should be the smaller of the two, or the file with single combination of the first X columns
###Assumes that the combination of the first X columns for each row are unique for the first file.
###usage is: perl combineFilesByFirstXColumns.pl 3 file.txt file2.txt > output.txt

my %methHash;

my %rows;
my $fileNumber = 1;
my @fileArray;
my $ncol=shift;
my $totalNcol;

@ARGV = map { s/(.*\.gz)\s*$/gzip -dc < $1|/;$_ } @ARGV;
my @files = @ARGV;

my $InputFile = shift;
open INPUT, "$InputFile" or die "$OS_ERROR Could not open $InputFile\nWell, crap\n";
while (my $input=<INPUT>) {
    chomp $input;
    my @columns = split("\t", $input);
    $totalNcol=scalar(@columns);
    my $reference = join("\t",@columns[0..($ncol-1)]);
    $rows{$reference}=join("\t",@columns[$ncol..(scalar(@columns)-1)]);
}
close INPUT;

$InputFile = shift;
open INPUT, "$InputFile" or die "$OS_ERROR Could not open $InputFile\nWell, crap\n";
while (my $input=<INPUT>) {
    chomp $input;
    my @columns = split("\t",$input);
    $totalNcol=scalar(@columns);
    my $reference = join("\t",@columns[0..($ncol-1)]);
    if(exists($rows{$reference})){
    print join("\t",$input,$rows{$reference})."\n";
    } #else {
#   print "\tNA" x ($totalNcol-$ncol);
#    }
}</code></pre>
</div>
<div class="row">

</div>
<div class="row">
<button class="source perl toggle btn btn-xs btn-primary">
<span class="glyphicon glyphicon-chevron-down"></span> perl source
</button>
<pre style=""><code class="source perl">#!/usr/bin/perl
use strict;
use English;
use warnings;

# This script takes in a list of columns (WITH NO SPACES) and a file, and keeps one of each occurence of the combination of the value of those columns. It always keeps the first occurence. 
# Syntax should be perl uniqueFileByColumnsV1.pl 1,3,5-10 fileIn.txt > fileOut.txt
# Note that the list of columns is separated by columns, and can include ranges if they are separated by a "-".

my %columnsHash;
my $cutcolumns = shift;
my @selectionColumns = split ",", $cutcolumns;

my @tempArray;
for(my $i=0;$i<@selectionColumns;$i++) {
    if($selectionColumns[$i] =~ /-/){
        my ($start,$stop) = split "-", $selectionColumns[$i];
        for(my $j=$start;$j<=$stop;$j++) {
            push(@tempArray,$j);
        }
    } else {
        push(@tempArray,$selectionColumns[$i]); 
    }
    
}
@selectionColumns=@tempArray;


@ARGV = map { s/(.*\.gz)\s*$/gzip -dc < $1|/;$_ } @ARGV;

my $inputFileName2 = shift;

open INPUTFILE2, "$inputFileName2" or die "$OS_ERROR Could not open first input\nWell, crap\n";
while (my $input = <INPUTFILE2>){
    chomp $input;
    my $hashKey="";
    my @columns = split "\t", $input;
    for(@selectionColumns){
        $hashKey = join("",$hashKey,$columns[$_-1]);
    }
    if(!exists($columnsHash{$hashKey}) ) {
        print $input, "\n";
        $columnsHash{$hashKey}=1;
    }
}</code></pre>
</div>
<div class="row">

</div>
<div class="row">
<button class="source perl toggle btn btn-xs btn-primary">
<span class="glyphicon glyphicon-chevron-down"></span> perl source
</button>
<pre style=""><code class="source perl">#!/usr/bin/perl
use strict;
use warnings;

## This script takes in the blast results from 

my %storagehash;

while(my $input = <>) {
    chomp $input;
    if($input =~ /^#/) {
       print $input, "\n";
   } else {
       my @columns = split "\t", $input;
       my $readname = $columns[2];
       my $sample = $columns[0];
       if(exists $storagehash{join("",$readname,$sample)}) {
       $input=concatenateDifferences($input); #compare the stored information, and add any differences to the line, adding a "/" between
       $storagehash{join("",$readname,$sample)}=$input;
       } else {
       $storagehash{join("",$readname,$sample)}=$input;
       }
   }
}

PrintSingleLevelHash(%storagehash);

sub concatenateDifferences {
    my $data=shift;
    my @columnsToAdd = split "\t", $data;
    my $readname = $columnsToAdd[2];
    my $sample = $columnsToAdd[0];
    my @columnsInHash = split "\t", $storagehash{join("", $readname, $sample)};
    for(my $i = 0; $i < scalar(@columnsToAdd); $i++){
        if($columnsInHash[$i] !~ /\Q$columnsToAdd[$i]\E/) {
            $columnsInHash[$i] = join("/", $columnsInHash[$i], $columnsToAdd[$i]);
        }
    }
    return join("\t", @columnsInHash);
}

sub PrintSingleLevelHash {
    my %hash = @_;
    for my $keys (keys %hash) {
        print $hash{$keys} . "\n";
    }
}</code></pre>
</div>
<div class="row">
<button class="source bash toggle btn btn-xs btn-primary">
<span class="glyphicon glyphicon-chevron-down"></span> bash source
</button>
<pre style=""><code class="source bash">fileList=(output2/blast/output/*.blastResults2.txt.gz) 
 
for i in "${!fileList[@]}"; do 
  fileList[$i]="${fileList[$i]##*/merged_products_}"
  fileList[$i]="${fileList[$i]%.blastResults2.txt.gz}"
done 

for i in "${!fileList[@]}" 
do
  # move gi to first column  14 cols
  zcat output2/blast/output/blastGICountsStats_${fileList[$i]}.txt.gz | gawk -F"\t" 'BEGIN {OFS = "\t"} {print $3,$1,$2,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14}' > temp
  
  ###########################   Truncated Species Name
  #combine the prior two files by gi number
  perl ~/SerreDLab-2/cannonm3/scripts/combineFilesByFirstXColumnsOrdered.pl 1 output2/blast/output/taxonomy/blastTaxaRaw_${fileList[$i]}Fixed.txt temp | cut -f 2- > output2/blast/output/blastStatsWithTaxaOutputRedundantSpecies_${fileList[$i]}.txt 
  
  # keep only one hit per species
  
  ###  Check the four numbers
  perl ~/SerreDLab-2/cannonm3/scripts/uniqueFileByColumnsV1.pl 1,2,3,4,14 output2/blast/output/blastStatsWithTaxaOutputRedundantSpecies_${fileList[$i]}.txt > output2/blast/output/blastStatsWithTaxaOutputUniqueSpecies_${fileList[$i]}.txt
  
  # concatenate duplicate hits
  grep -v "NotFound" output2/blast/output/blastStatsWithTaxaOutputUniqueSpecies_${fileList[$i]}.txt > temp.txt
  perl ~/SerreDLab-2/cannonm3/scripts/concatenateRepeatReadHitsForBlastV2.pl temp.txt > output2/blast/output/blastStatsWithTaxaOutputUniqueSpeciesConcatenated_${fileList[$i]}.txt
  
  ############################ Normal Species Name
  #combine the prior two files by gi number
  perl ~/SerreDLab-2/cannonm3/scripts/combineFilesByFirstXColumnsOrdered.pl 1 output2/blast/output/taxonomy/blastTaxaRaw_${fileList[$i]}Fixed.txt temp | cut -f 2- > output2/blast/output/blastStatsWithTaxaOutputRedundantSpeciesFullName_${fileList[$i]}.txt 

  # keep only one hit per species

  ###  Check the four numbers
  perl ~/SerreDLab-2/cannonm3/scripts/uniqueFileByColumnsV1.pl 1,2,3,4,14 output2/blast/output/blastStatsWithTaxaOutputRedundantSpeciesFullName_${fileList[$i]}.txt > output2/blast/output/blastStatsWithTaxaOutputUniqueSpeciesFullName_${fileList[$i]}.txt
  
  # concatenate duplicate hits
  grep -v "NotFound" output2/blast/output/blastStatsWithTaxaOutputUniqueSpeciesFullName_${fileList[$i]}.txt > temp.txt
  perl ~/SerreDLab-2/cannonm3/scripts/concatenateRepeatReadHitsForBlastV2.pl temp.txt > output2/blast/output/blastStatsWithTaxaOutputUniqueSpeciesFullNameConcatenated_${fileList[$i]}.txt
  
done</code></pre>
</div>
<h3 id="add-blasted-sequence-length-to-the-output">Add blasted sequence length to the output</h3>
<div class="row">
<button class="source bash toggle btn btn-xs btn-primary">
<span class="glyphicon glyphicon-chevron-down"></span> bash source
</button>
<pre style=""><code class="source bash">for file in output2/blast/inputFiles/merged_products_*.Unique.filtered.fa
do
  base=${file##*/}
  base=${base%.Unique.filtered.fa}
  perl ~/SerreDLab-3/cannonm3/scripts/fastaSeqLength.pl ${file} | perl -pe 's/\|.+gz//' > output2/blast/output/withSeqLen/${base}SeqLens.txt
done </code></pre>
</div>
<h3 id="summarize-blast-output-into-more-readable-table">Summarize BLAST output into more readable table</h3>
<div class="row">
<button class="source R toggle btn btn-xs btn-primary">
<span class="glyphicon glyphicon-chevron-down"></span> R source
</button>
<pre style=""><code class="source r">files <- list.files(path = "output2/blast/output/", pattern = "blastStatsWithTaxaOutputUniqueSpeciesFullNameConcatenated_.+", full.names = T )

for(primer in files) {
  baseName <- gsub(".+Concatenated_", "", primer)
  baseName <- gsub(".txt", "", baseName)

  seqLens <- read.delim(paste("output2/blast/output/withSeqLen/merged_products_", baseName, "SeqLens.txt", sep = ""), header = F, stringsAsFactors = F)
  colnames(seqLens) <- c("blastedReadName", "seqLength")
  
  dataDf <- read.delim(primer, header = T, stringsAsFactors = F)
  
  dataDf$Sample <- gsub("\\|$", "", dataDf$X.primerSample)
  dataDf$Sample <- gsub(".+\\|", "", dataDf$Sample)
  
  dataDf$Primer <- gsub("\\|.+", "", dataDf$X.primerSample)
  
  dataDf$identity <- gsub("\\/.+", "", dataDf$identity)
  
  dataDf$alignmentlength <- gsub("\\/.+", "", dataDf$alignmentlength)
  
  dataDf$blastedReadName <- gsub("\\|.+", "", dataDf$blastedReadName)
  
  dataDf <- merge(dataDf, seqLens, all.x = T)

  wantedCols <- c("Primer", "Sample", "count", "identity", "alignmentlength", "species", "superkingdom", "kingdom", "phylum", "class", "order", "family", "seqLength")
  
  dataDf <- dataDf[, colnames(dataDf) %in% wantedCols]
  
  summaryDf <- dataDf %>%
    group_by(., Primer, Sample, species, kingdom, phylum, class, order, family) %>%
    summarize(., count = sum(count), 
              maxIdent = max(as.numeric(identity)), 
              maxAlignLen = max(as.numeric(alignmentlength)), 
              minSeqLength = min(seqLength))
  
  write.table(summaryDf, file = paste( "output2/blast/output/blastStatsWithTaxaOutputUniqueSpeciesFullNameConcatenatedSummary_", baseName, ".txt", sep = ""), quote = F, sep = "\t", col.names = T, row.names = F)
  
}</code></pre>
</div>
<h3 id="for-haikels-data-spirur18s_1435-1858-data-dna_plate_3-and-dna_plate_4-were-switched-during-pcr-setup-as-noted-in-his-lab-book-need-to-switch-back-here">For Haikel’s data Spirur18S_1435-1858 data, DNA_Plate_3 and DNA_Plate_4 were switched during PCR setup as noted in his lab book, need to switch back here</h3>
<div class="row">
<button class="source bash toggle btn btn-xs btn-primary">
<span class="glyphicon glyphicon-chevron-down"></span> bash source
</button>
<pre style=""><code class="source bash">cp output2/blast/output/blastStatsWithTaxaOutputUniqueSpeciesFullNameConcatenatedSummary_Spirur18S_1435-1858.txt output2/blast/output/blastStatsWithTaxaOutputUniqueSpeciesFullNameConcatenatedSummaryOriginal_Spirur18S_1435-1858.txt
 
perl -pe 's/Plate_3/Pl\@te_4/' output2/blast/output/blastStatsWithTaxaOutputUniqueSpeciesFullNameConcatenatedSummaryOriginal_Spirur18S_1435-1858.txt | perl -pe 's/Plate_4/Pl\@te_3/' | perl -pe 's/Pl\@te/Plate/' > output2/blast/output/blastStatsWithTaxaOutputUniqueSpeciesFullNameConcatenatedSummary_Spirur18S_1435-1858.txt
 </code></pre>
</div>
<h3 id="make-separate-files-that-have-only-on-target-hits">Make separate files that have only on-target hits</h3>
<div class="row">
<button class="source bash toggle btn btn-xs btn-primary">
<span class="glyphicon glyphicon-chevron-down"></span> bash source
</button>
<pre style=""><code class="source bash">for primer in \
  Apicomp18S_365-613 \
  Eimeriorina18S_302-730 \
  FlaviallS_FlaviallAS2 \
  Kineto_18S4 \
  Microsporidia_18S \
  Parab18S_288-654 \
  Plasmo18S_883-1126 \
  Platy_18S3 \
  Spirur18S_1435-1858 \
  Spirurida_18S2 \
  Tricho_18S2
do
  echo ${primer}
  perl misc/filterBlastResultsByTaxa.pl \
    --targetTaxa misc/primerTargets/${primer}.txt \
    --blast output2/blast/output/blastStatsWithTaxaOutputUniqueSpeciesFullNameConcatenatedSummary_${primer}.txt \
      > output2/blast/output/onTarget/blastStatsWithTaxaOutputUniqueSpeciesFullNameConcatenatedSummary_${primer}.txt
done</code></pre>
</div>
<h3 id="combine-all-output-into-single-files">combine all output into single files</h3>
<div class="row">
<button class="source bash toggle btn btn-xs btn-primary">
<span class="glyphicon glyphicon-chevron-down"></span> bash source
</button>
<pre style=""><code class="source bash">rm output2/blast/output/blastStatsWithTaxaOutputUniqueSpeciesFullNameConcatenatedSummary_AllPrimers.txt
rm output2/blast/output/blastStatsWithTaxaOutputUniqueSpeciesFullNameConcatenatedSummary_OnTarget_AllPrimers.txt
rm output2/blast/output/blastStatsWithTaxaOutputUniqueSpeciesFullNameConcatenatedSummary_AllPrimers_NewSampleNames.txt
rm output2/blast/output/blastStatsWithTaxaOutputUniqueSpeciesFullNameConcatenatedSummary_OnTarget_AllPrimers_NewSampleNames.txt


cat output2/blast/output/blastStatsWithTaxaOutputUniqueSpeciesFullNameConcatenatedSummary_*.txt | head -n 1 > output2/blast/output/blastStatsWithTaxaOutputUniqueSpeciesFullNameConcatenatedSummary_AllPrimers.txt
 
cat output2/blast/output/blastStatsWithTaxaOutputUniqueSpeciesFullNameConcatenatedSummary_*.txt | grep -v "maxAlignLen" >> output2/blast/output/blastStatsWithTaxaOutputUniqueSpeciesFullNameConcatenatedSummary_AllPrimers.txt
 
cat output2/blast/output/onTarget/blastStatsWithTaxaOutputUniqueSpeciesFullNameConcatenatedSummary_*.txt | head -n 1 > output2/blast/output/blastStatsWithTaxaOutputUniqueSpeciesFullNameConcatenatedSummary_OnTarget_AllPrimers.txt
  
cat output2/blast/output/onTarget/blastStatsWithTaxaOutputUniqueSpeciesFullNameConcatenatedSummary_*.txt | grep -v "maxAlignLen" >> output2/blast/output/blastStatsWithTaxaOutputUniqueSpeciesFullNameConcatenatedSummary_OnTarget_AllPrimers.txt</code></pre>
</div>
<h3 id="add-info-for-better-sample-names">Add info for better sample names</h3>
<div class="row">
<button class="source R toggle btn btn-xs btn-primary">
<span class="glyphicon glyphicon-chevron-down"></span> R source
</button>
<pre style=""><code class="source r">sampleInfo <- read.delim("misc/sampleData.txt", header = F, stringsAsFactors = F)
colnames(sampleInfo) <- c("Sample", "NewSample")
 
allData <- read.delim("output2/blast/output/blastStatsWithTaxaOutputUniqueSpeciesFullNameConcatenatedSummary_AllPrimers.txt", header = T, stringsAsFactors = F)
allData$Sample <- gsub(".fastq.gz", "", allData$Sample)
allData <- merge(allData, sampleInfo)
allData$Sample <- allData$NewSample
allData <- allData[,-13]

write.table(allData, file = "output2/blast/output/blastStatsWithTaxaOutputUniqueSpeciesFullNameConcatenatedSummary_AllPrimers_NewSampleNames.txt", quote = F, sep = "\t", col.names = T, row.names = F)
  

onTarget <- read.delim("output2/blast/output/blastStatsWithTaxaOutputUniqueSpeciesFullNameConcatenatedSummary_OnTarget_AllPrimers.txt", header = T, stringsAsFactors = F)
onTarget$Sample <- gsub(".fastq.gz", "", onTarget$Sample)
onTarget <- merge(onTarget, sampleInfo)
onTarget$Sample <- onTarget$NewSample
onTarget <- onTarget[,-13]

write.table(onTarget, file = "output2/blast/output/blastStatsWithTaxaOutputUniqueSpeciesFullNameConcatenatedSummary_OnTarget_AllPrimers_NewSampleNames.txt", quote = F, sep = "\t", col.names = T, row.names = F)</code></pre>
</div>
<h2 id="compare-cdna-to-dna-results">Compare cDNA to DNA results</h2>
<div class="row">
<button class="source R toggle btn btn-xs btn-primary">
<span class="glyphicon glyphicon-chevron-down"></span> R source
</button>
<pre style=""><code class="source r">fileList <- list.files('output2/blast/output/onTarget/', pattern = '^blastStatsWithTaxaOutputUniqueSpeciesFullNameConcatenatedSummary_.+txt')
fileList <- fileList[grep("AllPrimers", fileList, invert = T)]
 
fileList <- fileList[grep("Culic", fileList, invert = T)]

dataDf <- data.frame()

for(inFile in fileList) {
  tempDf <- read.delim(paste("output2/blast/output/onTarget/", inFile, sep = ""))
  if(nrow(tempDf) > 1) {
    dataDf <- dataDf %>%
      bind_rows(., tempDf)
  }
}

dataDf <- dataDf[grepl("DB_", dataDf$Sample),]
dataDf <- subset(dataDf, count >= 10 & maxIdent >= 70 & grepl("water", dataDf$Sample)==FALSE)
dataDf$trap <- gsub("C", "", dataDf$Sample)
dataDf$trap <- gsub("DB_", "", dataDf$trap)
dataDf$trap <- gsub(".fastq.gz", "", dataDf$trap)
dataDf$molecule <- gsub("DB_", "", dataDf$Sample)
dataDf$molecule <- gsub("[0-9].+", "", dataDf$molecule)
dataDf$molecule[grepl("^$", dataDf$molecule)] <- "DNA"
dataDf$molecule[grepl("^C$", dataDf$molecule)] <- "RNA"
  
castDf <- reshape2::dcast(dataDf, species + trap + Primer ~ molecule, value.var = "count", fill = 0)

castDf$DNApos <- castDf$DNA > 0
castDf$RNApos <- castDf$RNA > 0
castDf$RNAHigher <- castDf$RNA > castDf$DNA

write.table(castDf, file = "cmpDnaCdnaTable.txt", quote = F, sep = "\t", col.names = T, row.names = F)

meltedCast <- reshape2::melt(castDf, id = c("species", "trap", "Primer", "RNAHigher", "DNApos", "RNApos"))

DnaRnaDf <- data.frame()

for(primer in unique(castDf$Primer)) {
  print(as.character(primer))
  subDf <- subset(castDf, Primer == primer)
  test <- as.data.frame(summary(as.factor(paste(subDf$DNApos, subDf$RNApos))))
  colnames(test) <- primer
  test$group <- rownames(test)
  DnaRnaDf <- plyr::join(DnaRnaDf, test, type = "full")
}

png(filename = "cmpDnaCdna.png", width = 3000, height = 2000, res = 300)
ggplot(meltedCast, aes(x = variable, y = value, group = paste(trap, species), colour = variable)) + 
  geom_point() + 
  geom_line(colour = "black") + 
  facet_wrap(~ Primer, scales = "free_y") + 
  theme(legend.position = "none") +
  xlab("") +
  ylab("Read count")
dev.off()

# ggplot(castDf, aes(x = DNA, y = RNA)) + 
#   geom_point() + 
#   facet_wrap(~ Primer, scales = "free") + 
#   geom_abline(slope = 1, intercept = 0)
# 
# ggplot(castDf, aes(x = RNA - DNA)) + 
#   geom_histogram(bins = 100) + 
#   facet_wrap(~ Primer, scales = "free")


pairedTtest <- castDf %>%
  filter(., Primer != "Tricho_18S2") %>%
  group_by(., Primer) %>%
  summarize(., pvalue = t.test(DNA, RNA, paired = T)$p.value, 
            n = length(DNA), 
            meanRNAminusDNA = mean(RNA - DNA), 
            medianRNAminusDNA = median(RNA - DNA))

pairedTtest$adjP <- p.adjust(pairedTtest$pvalue, method = "bonferroni")


write.table(pairedTtest, file = "cmpDnaCdnaTtests.txt", quote = F, sep = "\t", col.names = T, row.names = F)

meltedCast2 <- subset(meltedCast, Primer == "Apicomp18S_365-613" |
                        Primer == "Eimeriorina18S_302-730" |
                        Primer == "Plasmo18S_883-1126" |
                        Primer == "Kineto_18S4")
meltedCast2$isTheileria <- grepl("Theileria", meltedCast2$species)
meltedCast2$genus <- gsub(" .+", "", meltedCast2$species)
meltedCast2$RNAHigher[grep(TRUE, meltedCast2$RNAHigher)] <- "RNA higher"
meltedCast2$RNAHigher[grep(FALSE, meltedCast2$RNAHigher)] <- "DNA higher"


P1 <- ggplot(subset(meltedCast2, genus == "Plasmodium"), aes(x = variable, 
                                                             y = value, 
                                                             group = paste(trap, species, Primer))) + 
  geom_point() + 
  geom_line() + 
  facet_wrap(~ genus + RNAHigher) + 
  theme(legend.position = "none") +
  xlab("") +
  ylab("Read count")

P2 <- ggplot(subset(meltedCast2, genus == "Theileria"), aes(x = variable, 
                                                                              y = value, 
                                                                              group = paste(trap, species, Primer))) + 
  geom_point() + 
  geom_line() + 
  facet_wrap(~ genus + RNAHigher) + 
  theme(legend.position = "none") +
  xlab("") +
  ylab("Read count")

P3 <- ggplot(subset(meltedCast2, genus == "Trypanosoma"), aes(x = variable, 
                                                                              y = value, 
                                                                              group = paste(trap, species, Primer))) + 
  geom_point() + 
  geom_line() + 
  facet_wrap(~ genus + RNAHigher) + 
  theme(legend.position = "none") +
  xlab("") +
  ylab("Read count")

P4 <- ggplot(subset(meltedCast2, genus == "Strigomonas"), aes(x = variable, 
                                                                              y = value, 
                                                                              group = paste(trap, species, Primer))) + 
  geom_point() + 
  geom_line() + 
  facet_wrap(~ genus + RNAHigher) + 
  theme(legend.position = "none") +
  xlab("") +
  ylab("Read count")

P5 <- ggplot(subset(meltedCast2, genus == "Crithidia"), aes(x = variable, 
                                                                              y = value, 
                                                                              group = paste(trap, species, Primer))) + 
  geom_point() + 
  geom_line() + 
  facet_wrap(~ genus + RNAHigher) + 
  theme(legend.position = "none") +
  xlab("") +
  ylab("Read count")


png(filename = "cmpDnaCdnaTheileriaVsPlasmo.png", width = 3000, height = 6000, res = 300)
grid.arrange(P1, P2, P3, P4, P5, ncol = 1)
dev.off()

castDf$genus <- gsub(" .+", "", castDf$species)

testDdply <- castDf %>%
  filter(Primer != "FlaviallS_FlaviallAS2") %>%
  group_by(., genus) %>%
  summarize(., N = length(species), 
            percentRNAHigher = sum(RNAHigher) / length(RNAHigher))

write.table(testDdply, file = "cmpDnaCdnaPercentHigher.txt", quote = F, sep = "\t", col.names = T, row.names = F)</code></pre>
</div>
<h2 id="make-trees-of-results">Make trees of results</h2>
<h3 id="get-known-sequences-from-ncbi">Get known sequences from NCBI</h3>
<div class="row">
<button class="source R toggle btn btn-xs btn-primary">
<span class="glyphicon glyphicon-chevron-down"></span> R source
</button>
<pre style=""><code class="source r">primersToUse <- list.files(path = "output2/blast/output/", pattern = "^blastStatsWithTaxaOutputUniqueSpeciesFullNameConcatenatedSummary_.+txt")
primersToUse <- gsub("blastStatsWithTaxaOutputUniqueSpeciesFullNameConcatenatedSummary_", "", primersToUse)
primersToUse <- gsub(".txt", "", primersToUse)
primersToUse <- primersToUse[!primersToUse %in% "AllPrimers"]

primers <- read.delim("misc/primerKeyWithTarget.txt", header = F, stringsAsFactors = F)
primers <- primers[primers$V1 %in% primersToUse,]

for(i in 1:nrow(primers)) {
  primTree <- search_primer_pair(name = primers[i, 1], 
                                 forward = primers[i, 2], 
                                 reverse = primers[i, 3], 
                                 organism = primers[i, 4],
                                 num_permutations = 100,
                                 num_aligns = 50000, api_key = "4da437af9f4a6d26e1fb51be8d57af1e1009")

  taxa <- primTree$taxonomy
  write.table(taxa, paste("output2/primerTree/taxonomy/", primers[i, 1], ".txt", sep = ""), quote = F, sep = "\t", row.names = F, col.names = T)
  
  seqs <- primTree$sequence
  write.dna(seqs, paste("output2/primerTree/seqs/", primers[i, 1], ".fasta", sep = ""), format = "fasta")
  
}</code></pre>
</div>
<h3 id="align-known-and-unknown-sequences">Align known and unknown sequences</h3>
<div class="row">
<button class="source bash toggle btn btn-xs btn-primary">
<span class="glyphicon glyphicon-chevron-down"></span> bash source
</button>
<pre style=""><code class="source bash">for primer in \
  FlaviallS_FlaviallAS2 #\
  #Kineto_18S4 \
  #Microsporidia_18S \
  #Plasmo18S_883-1126
do 

# get on-target portion of blast results
# filter results by %identity and alignmentLength
# Put in last regex due to HWI Blast read keeping sample info
  perl misc/filterBlastResultsByTaxaSelectAbund.pl --minIdent 70 --minLen 100 --minCount 10 --targetTaxa misc/primerTargets/${primer}.txt --blast output2/blast/output/blastStatsWithTaxaOutputUniqueSpeciesConcatenated_${primer}.txt | perl -pe 's/:\|.+?\t/:\t/' > tempBlastSubset.txt
  
  
  #cut primer/sample name out of fasta
  cat output2/blast/inputFiles/merged_products_${primer}.Unique.filtered.fa | perl -pe 's/\|.+//' > tempBlastInputs.fasta
  
  # get sequences for on-target blast results
  perl ../sixthHbMvcCpDb/misc/outputFastaFromResults.pl --fasta tempBlastInputs.fasta --blast tempBlastSubset.txt | perl -pe 's/.fastq.gz//g' > tempBlastSequences.fasta
  
  # put species name in fasta
  cut -f 2,3 output2/primerTree/taxonomy/${primer}_taxonomyFixed.txt > tempSwitchFile.txt
  
  # switch: old\tnew
  perl ~/SerreDLab-3/cannonm3/scripts/switchFastaHeader.pl --fasta output2/primerTree/seqs/${primer}_sequences.fasta --switch tempSwitchFile.txt > tempSpeciesNames.fasta
  
  perl ~/SerreDLab-3/cannonm3/scripts/uniqueFastaByHeaderAndSeq.pl tempSpeciesNames.fasta > tempUniqueSpeciesNames.fasta
  
  cat tempBlastSequences.fasta tempUniqueSpeciesNames.fasta > tempCombined.fasta
  
  mafft --auto --thread 10 --adjustdirection tempCombined.fasta > ${primer}CombinedAligned.fasta
done
</code></pre>
</div>
<p>We changed where the input files were stored part way through this project, so I had to alter in this file</p>
perl -pe ‘s//home/matthewcannon/SerreDLab-3///local/projects-t4/aberdeen2ro/SerreDLab-4//’ misc/inputFiles.txt &gt; misc/inputFiles2.txt
<div class="row">
<button class="source bash toggle btn btn-xs btn-primary">
<span class="glyphicon glyphicon-chevron-down"></span> bash source
</button>
<pre style=""><code class="source bash">parallel -j 5 'zgrep -cH "^+$" {} >> output2/counts/rawReadCounts.txt' :::: misc/inputFiles2.txt
# sum: 
 
zgrep -cH "^+$" output2/pandaseqd/*.fastq.gz | perl -pe 's/:/\t/' > output2/counts/pandaSeqdCounts.txt
# sum: 


# primers removed counts: 

zcat output2/blast/mergedRaw/merged_products_*names.gz | cut -f 2,2 | perl -pe 's/,/\n/g' | wc -l
# 12,448,531

cat output2/blast/inputFiles/merged_products_*.Filtered.names | cut -f 2,2 | perl -pe 's/,/\n/g' | wc -l
# 6,796,105
</code></pre>
</div>
<div class="row">
<button class="source bash toggle btn btn-xs btn-primary">
<span class="glyphicon glyphicon-chevron-down"></span> bash source
</button>
<pre style=""><code class="source bash">## Count number of reads per primer
zgrep -c ">" output2/blast/mergedRaw/*.fa.gz | perl -pe 's/.+merged_products_//' | perl -pe 's/.fa.gz:/\t/' > output2/counts/originalPrimerCounts.txt &

## Count unique sequences
zgrep -c ">" output2/blast/mergedRaw/*.unique.fasta.gz | perl -pe 's/.+merged_products_//' | perl -pe 's/.unique.fasta.gz:/\t/' > output2/counts/uniquePrimerCounts.txt &

## Count sequences represented by filtered unique sequences
rm output2/counts/seqsInFilteredUniquePrimers.txt
for inFile in output2/blast/inputFiles/merged_products_*Filtered.names
do
  echo -n "${inFile} " | perl -pe 's/.+merged_products_//' | perl -pe 's/.Filtered.names//' >> output2/counts/seqsInFilteredUniquePrimers.txt
  cut -f 2,2 ${inFile} | perl -pe 's/,/\n/g' | wc -l >> output2/counts/seqsInFilteredUniquePrimers.txt
done
</code></pre>
</div>
<div class="row">
<button class="source R toggle btn btn-xs btn-primary">
<span class="glyphicon glyphicon-chevron-down"></span> R source
</button>
<pre style=""><code class="source r">originalPrimerCounts <- read.table("output2/counts/originalPrimerCounts.txt", quote="\"", comment.char="")

colnames(originalPrimerCounts) <- c("Primer", "OriginalCounts")

uniquePrimerCounts <- read.table("output2/counts/uniquePrimerCounts.txt", quote="\"", comment.char="")

colnames(uniquePrimerCounts) <- c("Primer", "UniqueSeqs")


seqsInFilteredUniquePrimers <- read.table("output2/counts/seqsInFilteredUniquePrimers.txt", quote="\"", comment.char="")

colnames(seqsInFilteredUniquePrimers) <- c("Primer", "SeqsInUniqueFiltered")

combinedDf <- merge(originalPrimerCounts, uniquePrimerCounts)
combinedDf <- merge(combinedDf, seqsInFilteredUniquePrimers)

combinedDf$proportionKept <- combinedDf$SeqsInUniqueFiltered / combinedDf$OriginalCounts

ggplot(combinedDf, aes(x = OriginalCounts, y = UniqueSeqs)) + geom_point()



ggplot(combinedDf, aes(x = OriginalCounts, y = SeqsInUniqueFiltered)) + 
  geom_point() +
  scale_y_log10() +
  scale_x_log10() +
  geom_abline(slope = 1, intercept = 0)</code></pre>
</div>
<div class="row">
<button class="source R toggle btn btn-xs btn-primary">
<span class="glyphicon glyphicon-chevron-down"></span> R source
</button>
<pre style=""><code class="source r">dataDf <- read.delim("output2/blast/output/blastStatsWithTaxaOutputUniqueSpeciesFullNameConcatenatedSummary_OnTarget_AllPrimers_NewSampleNames.txt")

dataDf <- subset(dataDf, count >= 10 & maxIdent >= 70)

dataDf <- subset(dataDf, Primer == "Apicomp18S_365-613" |
                         Primer == "Eimeriorina18S_302-730" |
                         Primer == "FlaviallS_FlaviallAS2" |
                         Primer == "Kineto_18S4" |
                         Primer == "Microsporidia_18S" |
                         Primer == "Parab18S_288-654" |
                         Primer == "Plasmo18S_883-1126" |
                         Primer == "Platy_18S3" |
                         Primer == "Spirur18S_1435-1858" |
                         Primer == "Spirurida_18S2" |
                         Primer == "Tricho_18S2" )

dataDf <- dataDf[grep("water", dataDf$Sample, invert = T),]
dataDf <- dataDf[grep("Positive", dataDf$Sample, invert = T),]
dataDf <- dataDf[grep("H20", dataDf$Sample, invert = T),]
dataDf <- dataDf[grep("neg-ctrl", dataDf$Sample, invert = T),]

dataDf$Group <- gsub("[-_].+", "", dataDf$Sample)
dataDf$Group <- gsub("DB", "MaryLand Mosquito Pools", dataDf$Group)
dataDf$Group <- gsub("DNA", "African Mosquitoes", dataDf$Group)
dataDf$Group <- gsub("Further", "Cambodian Mosquitoes", dataDf$Group)
dataDf$Group <- gsub("St", "Cambodian Mosquitoes", dataDf$Group)


dataDfSummary <- dataDf %>% 
  select(-Sample, -maxAlignLen, -minSeqLength) %>% 
  mutate(., Hit = 1) %>% 
  mutate_if(., is.factor, fct_explicit_na, na_level = "ND") %>%
  group_by(., Group, Primer, species, kingdom, phylum, class, order, family, maxIdent) %>%
  summarise(NumberPos = sum(Hit)) %>%
  ungroup(.,) %>%
  spread(Group, NumberPos) %>%
  replace(., is.na(.), "0") 
  
write.table(dataDfSummary, "speciesBySampleTypeTable.txt", quote = F, sep = "\t", row.names = F, col.names = T)</code></pre>
</div>
<div class="row">
<button class="source bash toggle btn btn-xs btn-primary">
<span class="glyphicon glyphicon-chevron-down"></span> bash source
</button>
<pre style=""><code class="source bash">perl misc/createGenusTable.pl --sample misc/sampleData.txt --data output2/blast/output/blastStatsWithTaxaOutputUniqueSpeciesFullNameConcatenatedSummary_OnTarget_AllPrimers.txt | sort -k1,2 > genusTable2.txt
</code></pre>
</div>
</div>
</div>
<div class="navbar navbar-fixed-bottom navbar-inverse">
<div class="container">
<div class="navbar-header">
<button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-responsive-collapse">
<span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span>
</button>
</div>
<div id="bottom-navbar" class="navbar-collapse collapse navbar-responsive-collapse">
<ul class="nav navbar-nav navbar-right">
<li class="nav">
<p class="navbar-text">
Toggle
</p>
</li>
<li class="dropup">
<a href="#" class="dropdown-toggle" data-toggle="dropdown">Code <b class="caret"></b></a>
<ul class="dropdown-menu">
<li class="dropdown-header">
Languages
</li>
<li class="active">
<a href="#" class="toggle-global source R" type="source.R">R</a>
</li>
<li class="active">
<a href="#" class="toggle-global source perl" type="source.perl">perl</a>
</li>
<li class="active">
<a href="#" class="toggle-global source bash" type="source.bash">bash</a>
</li>
<li>
<a href="#" type="all-source" class="toggle-global">All</a>
</li>
</ul>
</li>
<li class="dropup">
<a href="#" class="dropdown-toggle" data-toggle="dropdown">Output <b class="caret"></b></a>
<ul class="dropdown-menu">
<li class="dropdown-header">
Type
</li>
<li class="active">
<a href="#" class="toggle-global message" type="message">message</a>
</li>
<li class="active">
<a href="#" class="toggle-global output" type="output">output</a>
</li>
<li>
<a href="#" type="all-output" class="toggle-global">All</a>
</li>
</ul>
</li>
<li class="active">
<a href="#" type="figure" class="toggle-global">Figures</a>
</li>
</ul>
</div>
</div>
</div>
</div>
<div id="push">

</div>
<div id="footer">
<div class="container">
<p class="text-muted" id="credit">
Styled with <a href="https://github.com/jimhester/knitrBootstrap">knitrBootstrap</a>
</p>
</div>
</div>
<link rel="stylesheet" id="theme" href="https://netdna.bootstrapcdn.com/bootstrap/3.0.0/css/bootstrap.min.css" media="screen"></link><link rel="stylesheet" id="highlight" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/7.3/styles/default.min.css" media="screen"></link>
</div>
</body>
</html>
